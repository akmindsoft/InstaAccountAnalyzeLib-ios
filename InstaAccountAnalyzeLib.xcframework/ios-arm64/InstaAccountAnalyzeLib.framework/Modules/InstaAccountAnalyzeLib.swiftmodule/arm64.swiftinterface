// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name InstaAccountAnalyzeLib
import CoreGraphics
import Darwin
import Dispatch
import Foundation
@_exported import InstaAccountAnalyzeLib
import SQLite3
import Security
import Swift
import UIKit
import WebKit
public struct MediaModel {
  public init()
  public var uid: Swift.Int
  public var mediaId: Swift.String?
  public var userId: Swift.Int64?
  public var ownerUserId: Swift.Int64?
  public var isTaggedYou: Swift.Bool
  public var isSaved: Swift.Bool
  public var type: Swift.String?
  public var thumbnailUrl: Swift.String?
  public var shortcode: Swift.String?
  public var likeCount: Swift.Int?
  public var commentCount: Swift.Int?
  public var viewCount: Swift.Int?
  public var lastUpdateDate: Swift.Int64
  public var takenAt: Swift.Int64?
  public var isDelete: Swift.Bool
}
public protocol DeviceCollection {
  static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] { get }
}
extension DeviceCollection {
  public static func random() -> InstaAccountAnalyzeLib.Device!
}
public struct AnyDevice : InstaAccountAnalyzeLib.DeviceCollection {
  public static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] {
    get
  }
}
@_hasMissingDesignatedInitializers open class UserStatsDao {
  @objc deinit
}
public struct Blob {
  public let bytes: [Swift.UInt8]
  public init(bytes: [Swift.UInt8])
  public init(bytes: Swift.UnsafeRawPointer, length: Swift.Int)
  public func toHex() -> Swift.String
}
extension Blob : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Blob : Swift.Equatable {
}
public func == (lhs: InstaAccountAnalyzeLib.Blob, rhs: InstaAccountAnalyzeLib.Blob) -> Swift.Bool
final public class GCM : InstaAccountAnalyzeLib.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: InstaAccountAnalyzeLib.GCM.Mode, b: InstaAccountAnalyzeLib.GCM.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let options: InstaAccountAnalyzeLib.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: InstaAccountAnalyzeLib.GCM.Error, b: InstaAccountAnalyzeLib.GCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: InstaAccountAnalyzeLib.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: InstaAccountAnalyzeLib.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
  @objc deinit
}
public enum ExploreElement : InstaAccountAnalyzeLib.ParsedResponse {
  case story(InstaAccountAnalyzeLib.Tray)
  case media(InstaAccountAnalyzeLib.Media)
  case none
  public var rawResponse: InstaAccountAnalyzeLib.DynamicResponse {
    get
  }
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
final public class Poly1305 : InstaAccountAnalyzeLib.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: InstaAccountAnalyzeLib.Poly1305.Error, b: InstaAccountAnalyzeLib.Poly1305.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: InstaAccountAnalyzeLib.PKCS5.PBKDF1.Error, b: InstaAccountAnalyzeLib.PKCS5.PBKDF1.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: InstaAccountAnalyzeLib.PKCS5.PBKDF1.Variant, b: InstaAccountAnalyzeLib.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: InstaAccountAnalyzeLib.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
public struct StoryViewerModel {
  public init()
  public var storyId: Swift.String
  public var userId: Swift.Int64
  public var ownerUserId: Swift.Int64
  public var logDate: Swift.Int64
}
public struct StoryViewerWithMetadataModel {
  public init()
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
  public var storyViewer: InstaAccountAnalyzeLib.StoryViewerModel?
}
extension Recipient {
  public enum Reference {
    case users(_: [Swift.Int])
    case thread(Swift.String)
  }
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : InstaAccountAnalyzeLib.Cryptor, InstaAccountAnalyzeLib.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public struct OFB : InstaAccountAnalyzeLib.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.OFB.Error, b: InstaAccountAnalyzeLib.OFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
public struct UserTagModel {
  public init()
  public var mediaId: Swift.String?
  public var userId: Swift.Int64?
  public var ownerUserId: Swift.Int64?
  public var type: Swift.String?
  public var thumbnailUrl: Swift.String?
  public var shortcode: Swift.String?
  public var likeCount: Swift.Int?
  public var commentCount: Swift.Int?
  public var viewCount: Swift.Int?
  public var lastUpdateDate: Swift.Int64
  public var takenAt: Swift.Int64?
  public var isDeleted: Swift.Bool
}
public struct UserTagWithMetadataModel {
  public init()
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
  public var userTagModel: InstaAccountAnalyzeLib.UserTagModel?
}
extension Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: InstaAccountAnalyzeLib.Padding = .pkcs7) throws
}
public enum MediaType : Swift.String {
  case image
  case video
  case carousel
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MediaHandler : InstaAccountAnalyzeLib.Handler {
  final public func by(user: InstaAccountAnalyzeLib.User.Reference, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Media, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Media>)
  final public func info(for mediaId: Swift.String, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Media?, Swift.Error>) -> Swift.Void)
  final public func like(media mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func unlike(media mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func upload(photo: InstaAccountAnalyzeLib.Upload.Picture, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Upload.Response.Picture, Swift.Error>) -> Swift.Void)
  final public func upload(album: InstaAccountAnalyzeLib.Upload.Album, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Upload.Response.Album, Swift.Error>) -> Swift.Void)
  final public func upload(video: InstaAccountAnalyzeLib.Upload.Video, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Upload.Response.Video, Swift.Error>) -> Swift.Void)
  final public func delete(media mediaId: Swift.String, with type: InstaAccountAnalyzeLib.MediaType, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func edit(media mediaId: Swift.String, caption: Swift.String, tags: InstaAccountAnalyzeLib.User.Tags, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Media, Swift.Error>) -> Swift.Void)
  final public func likers(ofMedia mediaId: Swift.String, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func permalink(ofMedia mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct Endpoint {
}
extension QueryType {
  public func insert(_ encodable: Swift.Encodable, userInfo: [Swift.CodingUserInfoKey : Any] = [:], otherSetters: [InstaAccountAnalyzeLib.Setter] = []) throws -> InstaAccountAnalyzeLib.Insert
  public func update(_ encodable: Swift.Encodable, userInfo: [Swift.CodingUserInfoKey : Any] = [:], otherSetters: [InstaAccountAnalyzeLib.Setter] = []) throws -> InstaAccountAnalyzeLib.Update
}
extension Row {
  public func decode<V>(userInfo: [Swift.CodingUserInfoKey : Any] = [:]) throws -> V where V : Swift.Decodable
  public func decoder(userInfo: [Swift.CodingUserInfoKey : Any] = [:]) -> Swift.Decoder
}
public protocol SwiftyKey : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension SwiftyKey {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
public enum QueryError : Swift.Error, Swift.CustomStringConvertible {
  case noSuchTable(name: Swift.String)
  case noSuchColumn(name: Swift.String, columns: [Swift.String])
  case ambiguousColumn(name: Swift.String, similar: [Swift.String])
  case unexpectedNullValue(name: Swift.String)
  public var description: Swift.String {
    get
  }
}
final public class HMAC : InstaAccountAnalyzeLib.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: InstaAccountAnalyzeLib.HMAC.Error, b: InstaAccountAnalyzeLib.HMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: InstaAccountAnalyzeLib.HMAC.Variant, b: InstaAccountAnalyzeLib.HMAC.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: InstaAccountAnalyzeLib.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct Comment : InstaAccountAnalyzeLib.IdentifiableParsedResponse, InstaAccountAnalyzeLib.UserIdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var text: Swift.String {
    get
  }
  public var likes: Swift.Int {
    get
  }
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var createdAt: Swift.Int64 {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct MediaComments {
  public var rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public var caption: InstaAccountAnalyzeLib.Comment? {
    get
  }
  public var comments: Swift.Int {
    get
  }
  public var previews: [InstaAccountAnalyzeLib.Comment] {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum HTC : InstaAccountAnalyzeLib.DeviceCollection, InstaAccountAnalyzeLib.DeviceGenerating, Swift.CaseIterable {
  case ten
  public static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] {
    get
  }
  public func generate() -> InstaAccountAnalyzeLib.Device
  public typealias AllCases = [InstaAccountAnalyzeLib.HTC]
  public static var allCases: [InstaAccountAnalyzeLib.HTC] {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.HTC, b: InstaAccountAnalyzeLib.HTC) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum LG : Swift.CaseIterable, InstaAccountAnalyzeLib.DeviceCollection, InstaAccountAnalyzeLib.DeviceGenerating {
  case optimusF6
  case optimusG
  public static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] {
    get
  }
  public func generate() -> InstaAccountAnalyzeLib.Device
  public typealias AllCases = [InstaAccountAnalyzeLib.LG]
  public static var allCases: [InstaAccountAnalyzeLib.LG] {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.LG, b: InstaAccountAnalyzeLib.LG) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum Samsung : Swift.CaseIterable, InstaAccountAnalyzeLib.DeviceCollection, InstaAccountAnalyzeLib.DeviceGenerating {
  case galaxyNote3
  case galaxyS5
  case galaxyS6
  case galaxyTab
  public static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] {
    get
  }
  public func generate() -> InstaAccountAnalyzeLib.Device
  public typealias AllCases = [InstaAccountAnalyzeLib.Samsung]
  public static var allCases: [InstaAccountAnalyzeLib.Samsung] {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.Samsung, b: InstaAccountAnalyzeLib.Samsung) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum Sony : Swift.CaseIterable, InstaAccountAnalyzeLib.DeviceCollection, InstaAccountAnalyzeLib.DeviceGenerating {
  case xperiaZ5
  case z3Compact
  public static var all: [InstaAccountAnalyzeLib.DeviceCollection & InstaAccountAnalyzeLib.DeviceGenerating] {
    get
  }
  public func generate() -> InstaAccountAnalyzeLib.Device
  public typealias AllCases = [InstaAccountAnalyzeLib.Sony]
  public static var allCases: [InstaAccountAnalyzeLib.Sony] {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.Sony, b: InstaAccountAnalyzeLib.Sony) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension Error {
  public var requiresInstagramCode: Swift.Bool {
    get
  }
}
public enum AuthenticationError : Foundation.LocalizedError {
  case invalidPassword
  case invalidUsername
  case invalidCode
  case codeSent
  case invalidCache
  case checkpoint(suggestions: [Swift.String]?)
  case checkpointLoop
  case twoFactor
  public var errorDescription: Swift.String? {
    get
  }
}
public enum GenericError : Foundation.LocalizedError {
  case invalidEndpoint(Swift.String)
  case invalidUrl
  case weakObjectReleased
  case custom(_: Swift.String)
  case unknown
  public var errorDescription: Swift.String? {
    get
  }
}
public struct EngagedUserBookmarkedModel {
  public init()
  public var uid: Swift.Int
  public var userId: Swift.Int64?
  public var ownerUserId: Swift.Int64?
}
public struct EngagedUserBookmarkedWithMetadataModel {
  public init()
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
  public var engagedUserBookmarkedModel: InstaAccountAnalyzeLib.EngagedUserBookmarkedModel?
}
public enum SwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
}
public struct User : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public enum Reference : Swift.Hashable {
    case primaryKey(Swift.Int)
    case username(Swift.String)
    case me
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: InstaAccountAnalyzeLib.User.Reference, b: InstaAccountAnalyzeLib.User.Reference) -> Swift.Bool
  }
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var username: Swift.String {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var biography: Swift.String? {
    get
  }
  public var thumbnail: Foundation.URL? {
    get
  }
  public var avatar: Foundation.URL? {
    get
  }
  public var isPrivate: Swift.Bool {
    get
  }
  public var isVerified: Swift.Bool {
    get
  }
  public var friendship: InstaAccountAnalyzeLib.Friendship? {
    get
  }
  public var phoneNumber: Swift.String? {
    get
  }
  public var email: Swift.String? {
    get
  }
  public var website: Foundation.URL? {
    get
  }
  public var byline: Swift.String? {
    get
  }
  public var isBusiness: Swift.Bool? {
    get
  }
  public var followerCount: Swift.Int? {
    get
  }
  public var followingCount: Swift.Int? {
    get
  }
  public var mediaCount: Swift.Int? {
    get
  }
  public var profileContext: Swift.String? {
    get
  }
  public var socialContext: Swift.String? {
    get
  }
  public var reference: InstaAccountAnalyzeLib.User.Reference {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Friendship : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var isFollowedByYou: Swift.Bool {
    get
  }
  public var isFollowingYou: Swift.Bool? {
    get
  }
  public var isBlockedByYou: Swift.Bool? {
    get
  }
  public var isInYourCloseFriendsList: Swift.Bool {
    get
  }
  public var isPrivate: Swift.Bool {
    get
  }
  public var isRestricted: Swift.Bool {
    get
  }
  public var requestedToFollowYou: Swift.Bool {
    get
  }
  public var followRequestSent: Swift.Bool {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct SuggestedUser : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var algorithm: Swift.String? {
    get
  }
  public var isNewSuggestion: Swift.Bool {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct BlockedUser : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var userId: Swift.Int64 {
    get
  }
  public var blockAt: Foundation.Date {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct AnonymousUserInfoModel : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var username: Swift.String {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var biography: Swift.String? {
    get
  }
  public var thumbnail: Foundation.URL? {
    get
  }
  public var avatar: Foundation.URL? {
    get
  }
  public var isPrivate: Swift.Bool {
    get
  }
  public var isVerified: Swift.Bool {
    get
  }
  public var isBusiness: Swift.Bool? {
    get
  }
  public var followerCount: Swift.Int? {
    get
  }
  public var followingCount: Swift.Int? {
    get
  }
  public var mediaCount: Swift.Int? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct WebSuggestedUsers : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct SuggestedUsersResponseModel : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var users: [InstaAccountAnalyzeLib.WebSuggestedUsers] {
    get
  }
  public var hasNextPage: Swift.Bool {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct FollowRequestItemModel : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var text: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct FollowRequestsResponseModel : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var pageName: Swift.String? {
    get
  }
  public var isBlocked: Swift.Bool {
    get
  }
  public var link: Swift.String? {
    get
  }
  public var cursor: Swift.String? {
    get
  }
  public var requests: [InstaAccountAnalyzeLib.FollowRequestItemModel] {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct AppUserModel {
  public init()
  public var uid: Swift.Int
  public var userId: Swift.Int64?
  public var userName: Swift.String?
  public var email: Swift.String?
  public var fullName: Swift.String?
  public var profilePictureUrl: Swift.String?
  public var isDefault: Swift.Bool
  public var cookie: Swift.String?
  public var isDataInit: Swift.Bool
  public var isMediaDataInit: Swift.Bool
  public var createdAt: Swift.Int64?
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class CommentHandler : InstaAccountAnalyzeLib.Handler {
  final public func all(forMedia mediaId: Swift.String, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Comment, InstaAccountAnalyzeLib.MediaComments>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Comment>)
  final public func add(_ comment: Swift.String, to mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func delete(comment commentId: Swift.String, in mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func report(comment commentId: Swift.String, in mediaId: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  @objc deinit
}
@objc(PublicKey) public class _objc_PublicKey : ObjectiveC.NSObject, InstaAccountAnalyzeLib.SwiftyKey {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: InstaAccountAnalyzeLib.PublicKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc public static func publicKeys(pemEncoded pemString: Swift.String) -> [InstaAccountAnalyzeLib._objc_PublicKey]
  @objc deinit
  @objc override dynamic public init()
}
@objc(PrivateKey) public class _objc_PrivateKey : ObjectiveC.NSObject, InstaAccountAnalyzeLib.SwiftyKey {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: InstaAccountAnalyzeLib.PrivateKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers @objc(VerificationResult) public class _objc_VerificationResult : ObjectiveC.NSObject {
  @objc final public let isSuccessful: Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
@objc(ClearMessage) public class _objc_ClearMessage : ObjectiveC.NSObject, InstaAccountAnalyzeLib.SwiftyRSAMessage {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: InstaAccountAnalyzeLib.ClearMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func string(encoding rawEncoding: Swift.UInt) throws -> Swift.String
  @objc public func encrypted(with key: InstaAccountAnalyzeLib._objc_PublicKey, padding: InstaAccountAnalyzeLib.SwiftyRSAPadding) throws -> InstaAccountAnalyzeLib._objc_EncryptedMessage
  @objc public func signed(with key: InstaAccountAnalyzeLib._objc_PrivateKey, digestType: InstaAccountAnalyzeLib._objc_Signature.DigestType) throws -> InstaAccountAnalyzeLib._objc_Signature
  @objc public func verify(with key: InstaAccountAnalyzeLib._objc_PublicKey, signature: InstaAccountAnalyzeLib._objc_Signature, digestType: InstaAccountAnalyzeLib._objc_Signature.DigestType) throws -> InstaAccountAnalyzeLib._objc_VerificationResult
  @objc deinit
  @objc override dynamic public init()
}
@objc(EncryptedMessage) public class _objc_EncryptedMessage : ObjectiveC.NSObject, InstaAccountAnalyzeLib.SwiftyRSAMessage {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: InstaAccountAnalyzeLib.EncryptedMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func decrypted(with key: InstaAccountAnalyzeLib._objc_PrivateKey, padding: InstaAccountAnalyzeLib.SwiftyRSAPadding) throws -> InstaAccountAnalyzeLib._objc_ClearMessage
  @objc deinit
  @objc override dynamic public init()
}
@objc(Signature) public class _objc_Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: InstaAccountAnalyzeLib.Signature)
  @objc public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc deinit
  @objc override dynamic public init()
}
@_hasMissingDesignatedInitializers open class SwKeyStore {
  public enum SecError : Darwin.OSStatus, Swift.Error {
    case unimplemented
    case param
    case allocate
    case notAvailable
    case authFailed
    case duplicateItem
    case itemNotFound
    case interactionNotAllowed
    case decode
    case missingEntitlement
    public static var debugLevel: Swift.Int
    public typealias RawValue = Darwin.OSStatus
    public init?(rawValue: Darwin.OSStatus)
    public var rawValue: Darwin.OSStatus {
      get
    }
  }
  public static func upsertKey(_ pemKey: Swift.String, keyTag: Swift.String, options: [Foundation.NSString : Swift.AnyObject] = [:]) throws
  public static func getKey(_ keyTag: Swift.String) throws -> Swift.String
  public static func delKey(_ keyTag: Swift.String) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class SwKeyConvert {
  public enum SwError : Swift.Error {
    case invalidKey
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
    public static func == (a: InstaAccountAnalyzeLib.SwKeyConvert.SwError, b: InstaAccountAnalyzeLib.SwKeyConvert.SwError) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public typealias EncMode = InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode
    public static func encryptPEM(_ pemKey: Swift.String, passphrase: Swift.String, mode: InstaAccountAnalyzeLib.SwKeyConvert.PrivateKey.EncMode) throws -> Swift.String
    public static func decryptPEM(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func pemToPKCS8DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public static func derToPKCS8PEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PKCS8 {
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func addHeader(_ derKey: Foundation.Data) -> Foundation.Data
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PEM {
  public enum SwError : Swift.Error {
    case parse(Swift.String)
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EncryptedPrivateKey {
    public enum EncMode {
      case aes128CBC, aes256CBC
      public static func == (a: InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode, b: InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public static func toDER(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data, passphrase: Swift.String, mode: InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class CC {
  public typealias CCCryptorStatus = Swift.Int32
  public enum CCError : InstaAccountAnalyzeLib.CC.CCCryptorStatus, Swift.Error {
    case paramError
    case bufferTooSmall
    case memoryFailure
    case alignmentError
    case decodeError
    case unimplemented
    case overflow
    case rngFailure
    case unspecifiedError
    case callSequenceError
    case keySizeError
    case invalidKey
    public static var debugLevel: Swift.Int
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCCryptorStatus
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCCryptorStatus)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCCryptorStatus {
      get
    }
  }
  public static func generateRandom(_ size: Swift.Int) -> Foundation.Data
  public typealias CCDigestAlgorithm = Swift.UInt32
  public enum DigestAlgorithm : InstaAccountAnalyzeLib.CC.CCDigestAlgorithm {
    case none
    case md5
    case rmd128, rmd160, rmd256, rmd320
    case sha1
    case sha224, sha256, sha384, sha512
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCDigestAlgorithm
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCDigestAlgorithm)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCDigestAlgorithm {
      get
    }
  }
  public static func digest(_ data: Foundation.Data, alg: InstaAccountAnalyzeLib.CC.DigestAlgorithm) -> Foundation.Data
  public typealias CCHmacAlgorithm = Swift.UInt32
  public enum HMACAlg : InstaAccountAnalyzeLib.CC.CCHmacAlgorithm {
    case sha1, md5, sha256, sha384, sha512, sha224
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCHmacAlgorithm
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCHmacAlgorithm)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCHmacAlgorithm {
      get
    }
  }
  public static func HMAC(_ data: Foundation.Data, alg: InstaAccountAnalyzeLib.CC.HMACAlg, key: Foundation.Data) -> Foundation.Data
  public typealias CCOperation = Swift.UInt32
  public enum OpMode : InstaAccountAnalyzeLib.CC.CCOperation {
    case encrypt, decrypt
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCOperation
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCOperation)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCOperation {
      get
    }
  }
  public typealias CCMode = Swift.UInt32
  public enum BlockMode : InstaAccountAnalyzeLib.CC.CCMode {
    case ecb, cbc, cfb, ctr, f8, lrw, ofb, xts, rc4, cfb8
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCMode
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCMode)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCMode {
      get
    }
  }
  public enum AuthBlockMode : InstaAccountAnalyzeLib.CC.CCMode {
    case gcm, ccm
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCMode
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCMode)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCMode {
      get
    }
  }
  public typealias CCAlgorithm = Swift.UInt32
  public enum Algorithm : InstaAccountAnalyzeLib.CC.CCAlgorithm {
    case aes, des, threeDES, cast, rc4, rc2, blowfish
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCAlgorithm
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCAlgorithm)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCAlgorithm {
      get
    }
  }
  public typealias CCPadding = Swift.UInt32
  public enum Padding : InstaAccountAnalyzeLib.CC.CCPadding {
    case noPadding, pkcs7Padding
    public typealias RawValue = InstaAccountAnalyzeLib.CC.CCPadding
    public init?(rawValue: InstaAccountAnalyzeLib.CC.CCPadding)
    public var rawValue: InstaAccountAnalyzeLib.CC.CCPadding {
      get
    }
  }
  public static func crypt(_ opMode: InstaAccountAnalyzeLib.CC.OpMode, blockMode: InstaAccountAnalyzeLib.CC.BlockMode, algorithm: InstaAccountAnalyzeLib.CC.Algorithm, padding: InstaAccountAnalyzeLib.CC.Padding, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func cryptAuth(_ opMode: InstaAccountAnalyzeLib.CC.OpMode, blockMode: InstaAccountAnalyzeLib.CC.AuthBlockMode, algorithm: InstaAccountAnalyzeLib.CC.Algorithm, data: Foundation.Data, aData: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, tagLength: Swift.Int) throws -> Foundation.Data
  public static func digestAvailable() -> Swift.Bool
  public static func randomAvailable() -> Swift.Bool
  public static func hmacAvailable() -> Swift.Bool
  public static func cryptorAvailable() -> Swift.Bool
  public static func available() -> Swift.Bool
  @_hasMissingDesignatedInitializers open class GCM {
    public static func crypt(_ opMode: InstaAccountAnalyzeLib.CC.OpMode, algorithm: InstaAccountAnalyzeLib.CC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CCM {
    public static func crypt(_ opMode: InstaAccountAnalyzeLib.CC.OpMode, algorithm: InstaAccountAnalyzeLib.CC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class RSA {
    public typealias CCAsymmetricPadding = Swift.UInt32
    public enum AsymmetricPadding : InstaAccountAnalyzeLib.CC.RSA.CCAsymmetricPadding {
      case pkcs1
      case oaep
      public typealias RawValue = InstaAccountAnalyzeLib.CC.RSA.CCAsymmetricPadding
      public init?(rawValue: InstaAccountAnalyzeLib.CC.RSA.CCAsymmetricPadding)
      public var rawValue: InstaAccountAnalyzeLib.CC.RSA.CCAsymmetricPadding {
        get
      }
    }
    public enum AsymmetricSAPadding : Swift.UInt32 {
      case pkcs15
      case pss
      public typealias RawValue = Swift.UInt32
      public init?(rawValue: Swift.UInt32)
      public var rawValue: Swift.UInt32 {
        get
      }
    }
    public static func generateKeyPair(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
    public static func getPublicKeyFromPrivateKey(_ derKey: Foundation.Data) throws -> Foundation.Data
    public static func encrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: InstaAccountAnalyzeLib.CC.RSA.AsymmetricPadding, digest: InstaAccountAnalyzeLib.CC.DigestAlgorithm) throws -> Foundation.Data
    public static func decrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: InstaAccountAnalyzeLib.CC.RSA.AsymmetricPadding, digest: InstaAccountAnalyzeLib.CC.DigestAlgorithm) throws -> (Foundation.Data, Swift.Int)
    public static func sign(_ message: Foundation.Data, derKey: Foundation.Data, padding: InstaAccountAnalyzeLib.CC.RSA.AsymmetricSAPadding, digest: InstaAccountAnalyzeLib.CC.DigestAlgorithm, saltLen: Swift.Int) throws -> Foundation.Data
    public static func verify(_ message: Foundation.Data, derKey: Foundation.Data, padding: InstaAccountAnalyzeLib.CC.RSA.AsymmetricSAPadding, digest: InstaAccountAnalyzeLib.CC.DigestAlgorithm, saltLen: Swift.Int, signedData: Foundation.Data) throws -> Swift.Bool
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class DH {
    public enum DHParam {
      case rfc3526Group5
      case rfc2409Group2
      public static func == (a: InstaAccountAnalyzeLib.CC.DH.DHParam, b: InstaAccountAnalyzeLib.CC.DH.DHParam) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    open class DH {
      public init(dhParam: InstaAccountAnalyzeLib.CC.DH.DHParam) throws
      open func generateKey() throws -> Foundation.Data
      open func computeKey(_ peerKey: Foundation.Data) throws -> Foundation.Data
      @objc deinit
    }
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EC {
    public static func generateKeyPair(_ keySize: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func getPublicKeyFromPrivateKey(_ privateKey: Foundation.Data) throws -> Foundation.Data
    public static func signHash(_ privateKey: Foundation.Data, hash: Foundation.Data) throws -> Foundation.Data
    public static func verifyHash(_ publicKey: Foundation.Data, hash: Foundation.Data, signedData: Foundation.Data) throws -> Swift.Bool
    public static func computeSharedSecret(_ privateKey: Foundation.Data, publicKey: Foundation.Data) throws -> Foundation.Data
    public struct KeyComponents {
      public init(_ keySize: Swift.Int, _ x: Foundation.Data, _ y: Foundation.Data, _ d: Foundation.Data)
      public var keySize: Swift.Int
      public var x: Foundation.Data
      public var y: Foundation.Data
      public var d: Foundation.Data
    }
    public static func getPublicKeyComponents(_ keyData: Foundation.Data) throws -> InstaAccountAnalyzeLib.CC.EC.KeyComponents
    public static func getPrivateKeyComponents(_ keyData: Foundation.Data) throws -> InstaAccountAnalyzeLib.CC.EC.KeyComponents
    public static func createFromData(_ keySize: Darwin.size_t, _ x: Foundation.Data, _ y: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CRC {
    public typealias CNcrc = Swift.UInt32
    public enum Mode : InstaAccountAnalyzeLib.CC.CRC.CNcrc {
      case crc8, crc8ICODE, crc8ITU, crc8ROHC, crc8WCDMA, crc16, crc16CCITTTrue, crc16CCITTFalse, crc16USB, crc16XMODEM, crc16DECTR, crc16DECTX, crc16ICODE, crc16VERIFONE, crc16A, crc16B, crc16Fletcher, crc32Adler, crc32, crc32CASTAGNOLI, crc32BZIP2, crc32MPEG2, crc32POSIX, crc32XFER, crc64ECMA182
      public typealias RawValue = InstaAccountAnalyzeLib.CC.CRC.CNcrc
      public init?(rawValue: InstaAccountAnalyzeLib.CC.CRC.CNcrc)
      public var rawValue: InstaAccountAnalyzeLib.CC.CRC.CNcrc {
        get
      }
    }
    public static func crc(_ input: Foundation.Data, mode: InstaAccountAnalyzeLib.CC.CRC.Mode) throws -> Swift.UInt64
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CMAC {
    public static func AESCMAC(_ data: Foundation.Data, key: Foundation.Data) -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyDerivation {
    public typealias CCPseudoRandomAlgorithm = Swift.UInt32
    public enum PRFAlg : InstaAccountAnalyzeLib.CC.KeyDerivation.CCPseudoRandomAlgorithm {
      case sha1, sha224, sha256, sha384, sha512
      public typealias RawValue = InstaAccountAnalyzeLib.CC.KeyDerivation.CCPseudoRandomAlgorithm
      public init?(rawValue: InstaAccountAnalyzeLib.CC.KeyDerivation.CCPseudoRandomAlgorithm)
      public var rawValue: InstaAccountAnalyzeLib.CC.KeyDerivation.CCPseudoRandomAlgorithm {
        get
      }
    }
    public static func PBKDF2(_ password: Swift.String, salt: Foundation.Data, prf: InstaAccountAnalyzeLib.CC.KeyDerivation.PRFAlg, rounds: Swift.UInt32) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyWrap {
    public static let rfc3394IV: Foundation.Data
    public static func SymmetricKeyWrap(_ iv: Foundation.Data, kek: Foundation.Data, rawKey: Foundation.Data) throws -> Foundation.Data
    public static func SymmetricKeyUnwrap(_ iv: Foundation.Data, kek: Foundation.Data, wrappedKey: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
extension Data {
  public func hexadecimalString() -> Swift.String
  public func arrayOfBytes() -> [Swift.UInt8]
}
extension String {
  public func dataFromHexadecimalString() -> Foundation.Data?
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: InstaAccountAnalyzeLib.HKDF.Error, b: InstaAccountAnalyzeLib.HKDF.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: InstaAccountAnalyzeLib.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension AES : InstaAccountAnalyzeLib.Cryptors {
  final public func makeEncryptor() throws -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
  final public func makeDecryptor() throws -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
}
public enum Collation {
  case binary
  case nocase
  case rtrim
  case custom(Swift.String)
}
extension Collation : InstaAccountAnalyzeLib.Expressible {
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
}
extension Collation : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class UserHandler : InstaAccountAnalyzeLib.Handler {
  final public func current(delay: Swift.ClosedRange<Swift.Double>?, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.User, Swift.Error>) -> Swift.Void)
  final public func search(forUsersMatching query: Swift.String, completionHandler: @escaping (Swift.Result<[InstaAccountAnalyzeLib.User], Swift.Error>) -> Swift.Void)
  final public func user(_ user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.User, Swift.Error>) -> Swift.Void)
  final public func tagged(user: InstaAccountAnalyzeLib.User.Reference, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Media, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Media>)
  final public func following(user: InstaAccountAnalyzeLib.User.Reference, usersMatchinQuery query: Swift.String? = nil, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func followed(byUser user: InstaAccountAnalyzeLib.User.Reference, usersMatchinQuery query: Swift.String? = nil, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func recentActivities(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.SuggestedUser, InstaAccountAnalyzeLib.RecentActivity>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.SuggestedUser>)
  @available(*, unavailable, message: "Instagram no longer supports this endpoint.")
  final public func recentFollowingActivities(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.RecentActivity.Story, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.RecentActivity.Story>)
  final public func remove(follower user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func approveRequest(from user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func rejectRequest(from user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func pendingRequests(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func follow(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Friendship, Swift.Error>) -> Swift.Void)
  final public func unfollow(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Friendship, Swift.Error>) -> Swift.Void)
  final public func friendshipStatus(withUser user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Friendship, Swift.Error>) -> Swift.Void)
  final public func friendshipStatuses<C>(withUsersMatchingIDs ids: C, completionHandler: @escaping (Swift.Result<[InstaAccountAnalyzeLib.User.Reference : InstaAccountAnalyzeLib.Friendship], Swift.Error>) -> Swift.Void) where C : Swift.Collection, C.Element == Swift.Int
  final public func blocked(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.BlockedUser, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.BlockedUser>)
  final public func block(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func unblock(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func report(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func besties(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func detail(username: Swift.String, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.AnonymousUserInfoModel, Swift.Error>) -> Swift.Void)
  final public func getMostPostedUserInYourFeed(completionHandler: @escaping (Swift.Result<[InstaAccountAnalyzeLib.User], Swift.Error>) -> Swift.Void)
  final public func getUserSuggestions(userId: Swift.Int, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.SuggestedUsersResponseModel, Swift.Error>) -> Swift.Void)
  final public func requestedFollows(cursor: Swift.String?, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.FollowRequestsResponseModel, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : InstaAccountAnalyzeLib.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: InstaAccountAnalyzeLib.Padding, b: InstaAccountAnalyzeLib.Padding) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: InstaAccountAnalyzeLib.PKCS5.PBKDF2.Error, b: InstaAccountAnalyzeLib.PKCS5.PBKDF2.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: InstaAccountAnalyzeLib.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
@_hasMissingDesignatedInitializers open class NotificationDao {
  @objc deinit
}
extension Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: InstaAccountAnalyzeLib.SHA2.Variant) -> [Element]
  public func sha3(_ variant: InstaAccountAnalyzeLib.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: InstaAccountAnalyzeLib.Cipher) throws -> [Element]
  public func decrypt(cipher: InstaAccountAnalyzeLib.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : InstaAccountAnalyzeLib.Authenticator
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: InstaAccountAnalyzeLib.SHA3.Variant, b: InstaAccountAnalyzeLib.SHA3.Variant) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(variant: InstaAccountAnalyzeLib.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA3 : InstaAccountAnalyzeLib.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : InstaAccountAnalyzeLib.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
public struct Tray : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var items: [InstaAccountAnalyzeLib.TrayElement] {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TrayArchive : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var count: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct TrayElement : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var title: Swift.String? {
    get
  }
  public var updatedAt: Foundation.Date {
    get
  }
  public var expiringAt: Foundation.Date {
    get
  }
  public var lastSeenOn: Foundation.Date {
    get
  }
  public var containsUnseenMedia: Swift.Bool {
    get
  }
  public var containsBestiesOnlyMedia: Swift.Bool {
    get
  }
  public var isMuted: Swift.Bool {
    get
  }
  public var cover: InstaAccountAnalyzeLib.Cover? {
    get
  }
  public var media: [InstaAccountAnalyzeLib.Media] {
    get
  }
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct StoryViewers {
  public var rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public var users: Swift.Int {
    get
  }
  public var viewers: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct UserCounterModel {
  public init()
  public var userId: Swift.Int64
  public var count: Swift.Int
}
public struct UserStatsModel {
  public init()
  public var userId: Swift.Int64
  public var dateId: Swift.Int64
  public var followers: Swift.Int?
  public var followings: Swift.Int?
  public var lostFollowers: Swift.Int
  public var gainedFollowers: Swift.Int
  public var blockingMeFollowers: Swift.Int
  public var blockedByMeFollowers: Swift.Int
  public var totalPosts: Swift.Int?
  public var totalVideos: Swift.Int?
  public var totalPhotos: Swift.Int?
  public var totalComments: Swift.Int?
  public var totalLikes: Swift.Int?
  public var totalStories: Swift.Int?
  public var recentInteractionsCount: Swift.Int?
  public var recentSuggestionsCount: Swift.Int?
  public var deletedTagsCount: Swift.Int?
  public var deletedCommentsCount: Swift.Int?
  public var deletedLikesCount: Swift.Int?
  public var logDate: Swift.Int64
  public var weekMonthYear: Swift.String?
}
@_inheritsConvenienceInitializers final public class CBCMAC : InstaAccountAnalyzeLib.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
  override public init(key: Swift.Array<Swift.UInt8>) throws
}
@objc @_hasMissingDesignatedInitializers @available(iOS 12, *)
public class LoginWebViewController : UIKit.UIViewController {
  final public let handler: InstaAccountAnalyzeLib.APIHandler
  public var completionHandler: (InstaAccountAnalyzeLib.LoginWebViewController, Swift.Result<(InstaAccountAnalyzeLib.Authentication.Response, InstaAccountAnalyzeLib.APIHandler), Swift.Error>) -> Swift.Void
  public var indicator: UIKit.UIActivityIndicatorView! {
    get
    set
  }
  public var webView: InstaAccountAnalyzeLib.LoginWebView! {
    get
    set
  }
  @available(*, unavailable, message: "using a custom `userAgent` is no longer supported")
  public init(userAgent: Swift.String?, completionHandler: @escaping (InstaAccountAnalyzeLib.LoginWebViewController, Swift.Result<(InstaAccountAnalyzeLib.Authentication.Response, InstaAccountAnalyzeLib.APIHandler), Swift.Error>) -> Swift.Void)
  public init(completionHandler: @escaping (InstaAccountAnalyzeLib.LoginWebViewController, Swift.Result<(InstaAccountAnalyzeLib.Authentication.Response, InstaAccountAnalyzeLib.APIHandler), Swift.Error>) -> Swift.Void)
  @objc override dynamic public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Value {
  public var distinct: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
  public var count: InstaAccountAnalyzeLib.Expression<Swift.Int> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib._OptionalType, Self.UnderlyingType.WrappedType : InstaAccountAnalyzeLib.Value {
  public var distinct: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
  public var count: InstaAccountAnalyzeLib.Expression<Swift.Int> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Value, Self.UnderlyingType.Datatype : Swift.Comparable {
  public var max: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType?> {
    get
  }
  public var min: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType?> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib._OptionalType, Self.UnderlyingType.WrappedType : InstaAccountAnalyzeLib.Value, Self.UnderlyingType.WrappedType.Datatype : Swift.Comparable {
  public var max: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
  public var min: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Value, Self.UnderlyingType.Datatype : InstaAccountAnalyzeLib.Number {
  public var average: InstaAccountAnalyzeLib.Expression<Swift.Double?> {
    get
  }
  public var sum: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType?> {
    get
  }
  public var total: InstaAccountAnalyzeLib.Expression<Swift.Double> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib._OptionalType, Self.UnderlyingType.WrappedType : InstaAccountAnalyzeLib.Value, Self.UnderlyingType.WrappedType.Datatype : InstaAccountAnalyzeLib.Number {
  public var average: InstaAccountAnalyzeLib.Expression<Swift.Double?> {
    get
  }
  public var sum: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
  public var total: InstaAccountAnalyzeLib.Expression<Swift.Double> {
    get
  }
}
public func count(_ star: (InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>) -> InstaAccountAnalyzeLib.Expression<Swift.Int>
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.Rabbit.Error, b: InstaAccountAnalyzeLib.Rabbit.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension Rabbit : InstaAccountAnalyzeLib.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol PaginationProtocol {
  associatedtype Identifier : Swift.Hashable, Swift.LosslessStringConvertible
  var autoLoadMoreEnabled: Swift.Bool? { get }
  var moreAvailable: Swift.Bool? { get }
  var nextMaxId: Self.Identifier? { get }
  var numResults: Swift.Int? { get }
}
extension PaginationProtocol {
  public var autoLoadMoreEnabled: Swift.Bool? {
    get
  }
  public var moreAvailable: Swift.Bool? {
    get
  }
  public var numResults: Swift.Int? {
    get
  }
}
public protocol NestedPaginationProtocol : InstaAccountAnalyzeLib.PaginationProtocol {
  static var nextMaxIdPath: Swift.KeyPath<Self, Self.Identifier?> { get }
}
extension NestedPaginationProtocol {
  public var nextMaxId: Self.Identifier? {
    get
  }
}
public struct AnyPaginatedResponse {
  public var rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public typealias PaginationUpdateHandler<R, P> = (P, [R], InstaAccountAnalyzeLib.PaginationParameters, [R]) -> Swift.Void
public typealias LegacyPaginationUpdateHandler<R> = (R, InstaAccountAnalyzeLib.PaginationParameters, [R]) -> Swift.Void
public typealias PaginationCompletionHandler<R> = (Swift.Result<[R], Swift.Error>, InstaAccountAnalyzeLib.PaginationParameters) -> Swift.Void
public protocol DeviceGenerating {
  func generate() -> InstaAccountAnalyzeLib.Device
}
public struct Device : Swift.Codable {
  public let brand: Swift.String
  public let id: Swift.String
  public let model: Swift.String
  public let phoneGuid: Foundation.UUID
  public let deviceGuid: Foundation.UUID
  public let googleAdId: Foundation.UUID
  public let rankToken: Foundation.UUID
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol SQLiteBinding {
}
public protocol Number : InstaAccountAnalyzeLib.SQLiteBinding {
}
public protocol Value : InstaAccountAnalyzeLib.Expressible {
  associatedtype ValueType = Self
  associatedtype Datatype : InstaAccountAnalyzeLib.SQLiteBinding
  static var declaredDatatype: Swift.String { get }
  static func fromDatatypeValue(_ datatypeValue: Self.Datatype) -> Self.ValueType
  var datatypeValue: Self.Datatype { get }
}
extension Double : InstaAccountAnalyzeLib.Number, InstaAccountAnalyzeLib.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Double) -> Swift.Double
  public var datatypeValue: Swift.Double {
    get
  }
  public typealias ValueType = Swift.Double
  public typealias Datatype = Swift.Double
}
extension Int64 : InstaAccountAnalyzeLib.Number, InstaAccountAnalyzeLib.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Int64
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias ValueType = Swift.Int64
  public typealias Datatype = Swift.Int64
}
extension String : InstaAccountAnalyzeLib.SQLiteBinding, InstaAccountAnalyzeLib.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.String) -> Swift.String
  public var datatypeValue: Swift.String {
    get
  }
  public typealias ValueType = Swift.String
  public typealias Datatype = Swift.String
}
extension Blob : InstaAccountAnalyzeLib.SQLiteBinding, InstaAccountAnalyzeLib.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: InstaAccountAnalyzeLib.Blob) -> InstaAccountAnalyzeLib.Blob
  public var datatypeValue: InstaAccountAnalyzeLib.Blob {
    get
  }
  public typealias ValueType = InstaAccountAnalyzeLib.Blob
  public typealias Datatype = InstaAccountAnalyzeLib.Blob
}
extension Bool : InstaAccountAnalyzeLib.SQLiteBinding, InstaAccountAnalyzeLib.Value {
  public static var declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Bool
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias ValueType = Swift.Bool
  public typealias Datatype = Swift.Int64
}
extension Int : InstaAccountAnalyzeLib.Number, InstaAccountAnalyzeLib.Value {
  public static var declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Int
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias ValueType = Swift.Int
  public typealias Datatype = Swift.Int64
}
public struct BestTimeForPostModel {
  public init()
  public var totalComment: Swift.Int
  public var totalLike: Swift.Int
  public var totalView: Swift.Int
  public var totalPost: Swift.Int
  public var hour: Swift.Int
  public var dayOfWeek: Swift.Int
  public var ownerUserId: Swift.Int64?
  public var groupItem: Swift.Int
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: InstaAccountAnalyzeLib.ChaCha20.Error, b: InstaAccountAnalyzeLib.ChaCha20.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension ChaCha20 : InstaAccountAnalyzeLib.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension ChaCha20 {
  public struct ChaChaEncryptor : InstaAccountAnalyzeLib.Cryptor, InstaAccountAnalyzeLib.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 {
  public struct ChaChaDecryptor : InstaAccountAnalyzeLib.Cryptor, InstaAccountAnalyzeLib.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension ChaCha20 : InstaAccountAnalyzeLib.Cryptors {
  final public func makeEncryptor() -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
  final public func makeDecryptor() -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
}
public typealias SwiftyRSAPadding = Security.SecPadding
public enum SwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: InstaAccountAnalyzeLib.PrivateKey, publicKey: InstaAccountAnalyzeLib.PublicKey)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class FeedHandler : InstaAccountAnalyzeLib.Handler {
  final public func explore(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.ExploreElement, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.ExploreElement>)
  final public func liked(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Media, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Media>)
  final public func tag(_ tag: Swift.String, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Media, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Media>)
  final public func igtv(userId: Swift.String, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.IgtvResponseModel, Swift.Error>) -> Swift.Void)
  final public func timeline(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Media, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Media>)
  @objc deinit
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: InstaAccountAnalyzeLib.Blowfish.Error, b: InstaAccountAnalyzeLib.Blowfish.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: InstaAccountAnalyzeLib.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: InstaAccountAnalyzeLib.Padding) throws
  @objc deinit
}
extension Blowfish : InstaAccountAnalyzeLib.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.CTR.Error, b: InstaAccountAnalyzeLib.CTR.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
extension String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: InstaAccountAnalyzeLib.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : InstaAccountAnalyzeLib.Authenticator
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension MD5 : InstaAccountAnalyzeLib.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public struct FollowerStateChangeLogModel {
  public init(ownerUserId: Swift.Int64, logUserId: Swift.Int64, type: InstaAccountAnalyzeLib.FollowerStateTypes)
  public var uid: Swift.Int
  public var ownerUserId: Swift.Int64
  public var logDate: Swift.Int64
  public var logUserId: Swift.Int64
  public var type: InstaAccountAnalyzeLib.FollowerStateTypes
}
public enum FollowerStateTypes : Swift.Int {
  public typealias RawValue = Swift.Int
  case none
  case newFollower
  case lostFollower
  case blockedFollower
  case closedAccount
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct ECB : InstaAccountAnalyzeLib.BlockMode {
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String>, rhs: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Expression<Swift.String>
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String>, rhs: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.Expression<Swift.String?>
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Expression<Swift.String?>
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.Expression<Swift.String?>
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String>, rhs: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.String>
public func + (lhs: InstaAccountAnalyzeLib.Expression<Swift.String?>, rhs: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.String?>
public func + (lhs: Swift.String, rhs: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Expression<Swift.String>
public func + (lhs: Swift.String, rhs: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.Expression<Swift.String?>
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func + <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func - <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func * <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func / <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
prefix public func - <V>(rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
prefix public func - <V>(rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
prefix public func ~ <V>(rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
prefix public func ~ <V>(rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V?> where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V?) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: V?, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V?) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: V?, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Equatable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: InstaAccountAnalyzeLib.Expression<V?>, rhs: V) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: V, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.ClosedRange<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.ClosedRange<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.Range<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.Range<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeThrough<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeThrough<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeUpTo<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeUpTo<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeFrom<V>, rhs: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func ~= <V>(lhs: Swift.PartialRangeFrom<V>, rhs: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?> where V : InstaAccountAnalyzeLib.Value, V : Swift.Comparable, V.Datatype : InstaAccountAnalyzeLib.Value, V.Datatype : Swift.Comparable
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: Swift.Bool) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func && (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: Swift.Bool) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func && (lhs: Swift.Bool, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func && (lhs: Swift.Bool, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>, rhs: Swift.Bool) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func || (lhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, rhs: Swift.Bool) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
public func || (lhs: Swift.Bool, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
public func || (lhs: Swift.Bool, rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
prefix public func ! (rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
prefix public func ! (rhs: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MessageHandler : InstaAccountAnalyzeLib.Handler {
  final public func inbox(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.Thread, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.Thread>)
  final public func send(_ text: Swift.String, to receipients: InstaAccountAnalyzeLib.Recipient.Reference, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func `in`(thread: Swift.String, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Thread, Swift.Error>) -> Swift.Void)
  final public func recent(completionHandler: @escaping (Swift.Result<[InstaAccountAnalyzeLib.Recipient], Swift.Error>) -> Swift.Void)
  final public func ranked(completionHandler: @escaping (Swift.Result<[InstaAccountAnalyzeLib.Recipient], Swift.Error>) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class InstaAccountAnalyzeLib {
  public static func initSdk(licenseKey: Swift.String, callback: @escaping (Swift.Bool) -> Swift.Void) throws
  public static func getInstaFetcherRepository() throws -> InstaAccountAnalyzeLib.IInstaFetcherProcessor
  public static func getDatabaseRepository() throws -> InstaAccountAnalyzeLib.IDBRepository
  public static func getProcessorRepository() throws -> InstaAccountAnalyzeLib.IProcessorRepository
  public static func initRepository(completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  public static func initRepositoryWithoutAuth(completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  public static func initRepositoryLogin(userId: Swift.Int64, completionHandler: @escaping (Swift.Bool, InstaAccountAnalyzeLib.User?) -> Swift.Void)
  @objc deinit
}
public class EncryptedMessage : InstaAccountAnalyzeLib.SwiftyRSAMessage {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: InstaAccountAnalyzeLib.PrivateKey, padding: InstaAccountAnalyzeLib.SwiftyRSAPadding) throws -> InstaAccountAnalyzeLib.ClearMessage
  @objc deinit
}
precedencegroup ColumnAssignment {
  associativity: left
  assignment: true
  lowerThan: AssignmentPrecedence
}
infix operator <- : ColumnAssignment
public struct Setter {
}
extension Setter : InstaAccountAnalyzeLib.Expressible {
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
}
public func <- <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value
public func <- <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value
public func <- <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value
public func <- <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value
public func <- <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V?) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value
public func += (column: InstaAccountAnalyzeLib.Expression<Swift.String>, value: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Setter
public func += (column: InstaAccountAnalyzeLib.Expression<Swift.String>, value: Swift.String) -> InstaAccountAnalyzeLib.Setter
public func += (column: InstaAccountAnalyzeLib.Expression<Swift.String?>, value: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Setter
public func += (column: InstaAccountAnalyzeLib.Expression<Swift.String?>, value: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.Setter
public func += (column: InstaAccountAnalyzeLib.Expression<Swift.String?>, value: Swift.String) -> InstaAccountAnalyzeLib.Setter
public func += <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func += <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func += <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func += <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func += <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func -= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func -= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func -= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func -= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func -= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func *= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func *= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func *= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func *= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func *= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func /= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func /= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func /= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func /= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func /= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype : InstaAccountAnalyzeLib.Number
public func %= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func %= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func %= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func %= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func %= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func &= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func &= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func &= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func &= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func &= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func |= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func |= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func |= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func |= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func |= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: InstaAccountAnalyzeLib.Expression<V>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: InstaAccountAnalyzeLib.Expression<V?>, value: V) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
postfix public func ++ <V>(column: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
postfix public func ++ <V>(column: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
postfix public func -- <V>(column: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
postfix public func -- <V>(column: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Setter where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
public protocol IProcessorRepository {
  static func getInstance(instaFetcher: InstaAccountAnalyzeLib.IInstaFetcherProcessor) -> InstaAccountAnalyzeLib.IProcessorRepository
  func getUserFollowersAndFollowingsBatch(userId: Swift.Int64?, progressHandler: ((Swift.Int) -> Swift.Void)?) -> Swift.Bool
  func getUserFollowersAndFollowingsBatch(userId: Swift.Int64?, progressHandler: ((Swift.Int) -> Swift.Void)?, followersMaxPage: InstaAccountAnalyzeLib.PaginationParameters, followingsMaxPage: InstaAccountAnalyzeLib.PaginationParameters) -> Swift.Bool
  func getUserFollowersAndFollowingsOnlyBatch(userId: Swift.Int64?, progressHandler: ((Swift.Int) -> Swift.Void)?) -> Swift.Bool
  func getUserFollowersAndFollowingsOnlyBatch(userId: Swift.Int64?, progressHandler: ((Swift.Int) -> Swift.Void)?, followersMaxPage: InstaAccountAnalyzeLib.PaginationParameters, followingsMaxPage: InstaAccountAnalyzeLib.PaginationParameters) -> Swift.Bool
  func getUserBestFriendsDataBatch(userId: Swift.Int64)
  func getUserBlockedsDataBatch(userId: Swift.Int64)
  func getUserMediaDataBatch(userId: Swift.Int64)
  func getUserMediaDataBatch(userId: Swift.Int64, maxPage: InstaAccountAnalyzeLib.PaginationParameters)
  func getUserMediaDataOnlyFirstPageBatch(userId: Swift.Int64)
  func getUserMediaDataListOnlyBatch(userId: Swift.Int64)
  func getUserMediaDataListOnlyBatch(userId: Swift.Int64, maxPage: InstaAccountAnalyzeLib.PaginationParameters)
  func getUserMediaDataCommentAndLikeOnlyBatch(userId: Swift.Int64)
  func getUserStoriesBatch(userId: Swift.Int64)
  func getUserArchivedStoryViewersBatch(userId: Swift.Int64, storyIds: [Swift.String])
  func getLikedFeedsBatch(userId: Swift.Int64)
  func getTaggedFeedsBatch(userId: Swift.Int64)
  func updateUserStatsBatch(userId: Swift.Int64)
  func getUserArchivedStoryBatch(userId: Swift.Int64)
  func getUserSuggestedUsersBatch(userId: Swift.Int64)
  func processUserMediaPopularDaysAndHours(userId: Swift.Int64)
  func getUserPendingFriendRequestsBatch(userId: Swift.Int64)
}
public struct MediaCommenterModel {
  public init()
  public var commentId: Swift.Int64
  public var userId: Swift.Int64
  public var mediaId: Swift.String?
  public var commentText: Swift.String?
  public var ownerUserId: Swift.Int64?
  public var isDelete: Swift.Bool?
  public var createdAt: Swift.Int64?
}
extension String {
  public func decryptBase64ToString(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Swift.Array<Swift.UInt8>
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Number {
  public var absoluteValue: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib._OptionalType, Self.UnderlyingType.WrappedType : InstaAccountAnalyzeLib.Number {
  public var absoluteValue: InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType == Swift.Double {
  public func round(_ precision: Swift.Int? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
}
extension ExpressionType where Self.UnderlyingType == Swift.Double? {
  public func round(_ precision: Swift.Int? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Value, Self.UnderlyingType.Datatype == Swift.Int64 {
  public static func random() -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
}
extension ExpressionType where Self.UnderlyingType == Foundation.Data {
  public static func random(_ length: Swift.Int) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public static func allZeros(_ length: Swift.Int) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public var length: InstaAccountAnalyzeLib.Expression<Swift.Int> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType == Foundation.Data? {
  public var length: InstaAccountAnalyzeLib.Expression<Swift.Int?> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType == Swift.String {
  public var length: InstaAccountAnalyzeLib.Expression<Swift.Int> {
    get
  }
  public var lowercaseString: InstaAccountAnalyzeLib.Expression<Swift.String> {
    get
  }
  public var uppercaseString: InstaAccountAnalyzeLib.Expression<Swift.String> {
    get
  }
  public func like(_ pattern: Swift.String, escape character: Swift.Character? = nil) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func like(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String>, escape character: Swift.Character? = nil) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func glob(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func match(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func regexp(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func collate(_ collation: InstaAccountAnalyzeLib.Collation) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func ltrim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func rtrim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func trim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func replace(_ pattern: Swift.String, with replacement: Swift.String) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func substring(_ location: Swift.Int, length: Swift.Int? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public subscript(range: Swift.Range<Swift.Int>) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
}
extension ExpressionType where Self.UnderlyingType == Swift.String? {
  public var length: InstaAccountAnalyzeLib.Expression<Swift.Int?> {
    get
  }
  public var lowercaseString: InstaAccountAnalyzeLib.Expression<Swift.String?> {
    get
  }
  public var uppercaseString: InstaAccountAnalyzeLib.Expression<Swift.String?> {
    get
  }
  public func like(_ pattern: Swift.String, escape character: Swift.Character? = nil) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
  public func like(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String>, escape character: Swift.Character? = nil) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
  public func glob(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
  public func match(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func regexp(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
  public func collate(_ collation: InstaAccountAnalyzeLib.Collation) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func ltrim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func rtrim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func trim(_ characters: Swift.Set<Swift.Character>? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func replace(_ pattern: Swift.String, with replacement: Swift.String) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public func substring(_ location: Swift.Int, length: Swift.Int? = nil) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType>
  public subscript(range: Swift.Range<Swift.Int>) -> InstaAccountAnalyzeLib.Expression<Self.UnderlyingType> {
    get
  }
}
extension Collection where Self.Element : InstaAccountAnalyzeLib.Value {
  public func contains(_ expression: InstaAccountAnalyzeLib.Expression<Self.Iterator.Element>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func contains(_ expression: InstaAccountAnalyzeLib.Expression<Self.Iterator.Element?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
}
extension String {
  public func like(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String>, escape character: Swift.Character? = nil) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
}
public func ?? <V>(optional: InstaAccountAnalyzeLib.Expression<V?>, defaultValue: V) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value
public func ?? <V>(optional: InstaAccountAnalyzeLib.Expression<V?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value
public func ?? <V>(optional: InstaAccountAnalyzeLib.Expression<V?>, defaultValue: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.Expression<V> where V : InstaAccountAnalyzeLib.Value
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: InstaAccountAnalyzeLib.AES.Error, b: InstaAccountAnalyzeLib.AES.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: InstaAccountAnalyzeLib.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: InstaAccountAnalyzeLib.BlockMode, padding: InstaAccountAnalyzeLib.Padding = .pkcs7) throws
  @objc deinit
}
extension AES : InstaAccountAnalyzeLib.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct InstaUserMetadataModel {
  public init()
  public var userId: Swift.Int64?
  public var userName: Swift.String?
  public var fullName: Swift.String?
  public var profilePictureUrl: Swift.String?
  public var isPrivate: Swift.Bool?
  public var isVerified: Swift.Bool?
  public var isAccountDeletedOrDisabled: Swift.Bool?
  public var lastUpdateDate: Swift.Int64
}
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA1 : InstaAccountAnalyzeLib.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public class PaginationParameters {
  public var maxPagesToLoad: Swift.Int
  public var loadedPages: Swift.Int
  public var currentMaxId: Swift.String?
  public var nextMaxId: Swift.String?
  public init(startingAt maxId: Swift.String? = nil, maxPagesToLoad: Swift.Int = 1)
  public init(_ paginationParameters: InstaAccountAnalyzeLib.PaginationParameters)
  public static let everything: InstaAccountAnalyzeLib.PaginationParameters
  @available(*, unavailable, message: "use `init` instead.")
  public static func maxPagesToLoad(maxPages: Swift.Int) -> InstaAccountAnalyzeLib.PaginationParameters
  @objc deinit
}
extension Connection {
  final public func createFunction<Z>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping () -> Z) throws -> (() -> InstaAccountAnalyzeLib.Expression<Z>) where Z : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping () -> Z?) throws -> (() -> InstaAccountAnalyzeLib.Expression<Z?>) where Z : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A) -> Z) throws -> ((InstaAccountAnalyzeLib.Expression<A>) -> InstaAccountAnalyzeLib.Expression<Z>) where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?) -> Z) throws -> ((InstaAccountAnalyzeLib.Expression<A?>) -> InstaAccountAnalyzeLib.Expression<Z>) where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A) -> Z?) throws -> ((InstaAccountAnalyzeLib.Expression<A>) -> InstaAccountAnalyzeLib.Expression<Z?>) where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?) -> Z?) throws -> ((InstaAccountAnalyzeLib.Expression<A?>) -> InstaAccountAnalyzeLib.Expression<Z?>) where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B) -> Z) throws -> (InstaAccountAnalyzeLib.Expression<A>, InstaAccountAnalyzeLib.Expression<B>) -> InstaAccountAnalyzeLib.Expression<Z> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B) -> Z) throws -> (InstaAccountAnalyzeLib.Expression<A?>, InstaAccountAnalyzeLib.Expression<B>) -> InstaAccountAnalyzeLib.Expression<Z> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B?) -> Z) throws -> (InstaAccountAnalyzeLib.Expression<A>, InstaAccountAnalyzeLib.Expression<B?>) -> InstaAccountAnalyzeLib.Expression<Z> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B) -> Z?) throws -> (InstaAccountAnalyzeLib.Expression<A>, InstaAccountAnalyzeLib.Expression<B>) -> InstaAccountAnalyzeLib.Expression<Z?> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B?) -> Z) throws -> (InstaAccountAnalyzeLib.Expression<A?>, InstaAccountAnalyzeLib.Expression<B?>) -> InstaAccountAnalyzeLib.Expression<Z> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B) -> Z?) throws -> (InstaAccountAnalyzeLib.Expression<A?>, InstaAccountAnalyzeLib.Expression<B>) -> InstaAccountAnalyzeLib.Expression<Z?> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B?) -> Z?) throws -> (InstaAccountAnalyzeLib.Expression<A>, InstaAccountAnalyzeLib.Expression<B?>) -> InstaAccountAnalyzeLib.Expression<Z?> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B?) -> Z?) throws -> (InstaAccountAnalyzeLib.Expression<A?>, InstaAccountAnalyzeLib.Expression<B?>) -> InstaAccountAnalyzeLib.Expression<Z?> where Z : InstaAccountAnalyzeLib.Value, A : InstaAccountAnalyzeLib.Value, B : InstaAccountAnalyzeLib.Value
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 12, *)
public class LoginWebView : WebKit.WKWebView, WebKit.WKNavigationDelegate {
  public var didReachEndOfLoginFlow: (() -> Swift.Void)?
  @available(*, unavailable, message: "using a custom `userAgent` is no longer supported")
  public init(frame: CoreGraphics.CGRect, userAgent: Swift.String?, didReachEndOfLoginFlow: (() -> Swift.Void)? = nil)
  public init(frame: CoreGraphics.CGRect, didReachEndOfLoginFlow: (() -> Swift.Void)? = nil)
  @available(*, unavailable, message: "use `init(frame:didReachEndOfLoginFlow:)` instead.")
  public init(frame: CoreGraphics.CGRect, improvingReadability shouldImproveReadability: Swift.Bool, didReachEndOfLoginFlow: (() -> Swift.Void)? = nil)
  @available(*, unavailable)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @objc deinit
}
public struct CFB : InstaAccountAnalyzeLib.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.CFB.Error, b: InstaAccountAnalyzeLib.CFB.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public protocol QueryType : InstaAccountAnalyzeLib.Expressible {
  var clauses: InstaAccountAnalyzeLib.QueryClauses { get set }
  init(_ name: Swift.String, database: Swift.String?)
}
public protocol SchemaType : InstaAccountAnalyzeLib.QueryType {
  static var identifier: Swift.String { get }
}
extension SchemaType {
  public func select(_ column1: InstaAccountAnalyzeLib.Expressible, _ more: InstaAccountAnalyzeLib.Expressible...) -> Self
  public func select(distinct column1: InstaAccountAnalyzeLib.Expressible, _ more: InstaAccountAnalyzeLib.Expressible...) -> Self
  public func select(_ all: [InstaAccountAnalyzeLib.Expressible]) -> Self
  public func select(distinct columns: [InstaAccountAnalyzeLib.Expressible]) -> Self
  public func select(_ star: (InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>) -> Self
  public func select(distinct star: (InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>) -> Self
  public func select<V>(_ column: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.ScalarQuery<V> where V : InstaAccountAnalyzeLib.Value
  public func select<V>(_ column: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.ScalarQuery<V?> where V : InstaAccountAnalyzeLib.Value
  public func select<V>(distinct column: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.ScalarQuery<V> where V : InstaAccountAnalyzeLib.Value
  public func select<V>(distinct column: InstaAccountAnalyzeLib.Expression<V?>) -> InstaAccountAnalyzeLib.ScalarQuery<V?> where V : InstaAccountAnalyzeLib.Value
  public var count: InstaAccountAnalyzeLib.ScalarQuery<Swift.Int> {
    get
  }
}
extension QueryType {
  public func union(_ table: InstaAccountAnalyzeLib.QueryType) -> Self
  public func join(_ table: InstaAccountAnalyzeLib.QueryType, on condition: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func join(_ table: InstaAccountAnalyzeLib.QueryType, on condition: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func join(_ type: InstaAccountAnalyzeLib.JoinType, _ table: InstaAccountAnalyzeLib.QueryType, on condition: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func join(_ type: InstaAccountAnalyzeLib.JoinType, _ table: InstaAccountAnalyzeLib.QueryType, on condition: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func filter(_ predicate: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func filter(_ predicate: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func `where`(_ predicate: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func `where`(_ predicate: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func group(_ by: InstaAccountAnalyzeLib.Expressible...) -> Self
  public func group(_ by: [InstaAccountAnalyzeLib.Expressible]) -> Self
  public func group(_ by: InstaAccountAnalyzeLib.Expressible, having: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func group(_ by: InstaAccountAnalyzeLib.Expressible, having: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func group(_ by: [InstaAccountAnalyzeLib.Expressible], having: InstaAccountAnalyzeLib.Expression<Swift.Bool>) -> Self
  public func group(_ by: [InstaAccountAnalyzeLib.Expressible], having: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) -> Self
  public func order(_ by: InstaAccountAnalyzeLib.Expressible...) -> Self
  public func order(_ by: [InstaAccountAnalyzeLib.Expressible]) -> Self
  public func limit(_ length: Swift.Int?) -> Self
  public func limit(_ length: Swift.Int, offset: Swift.Int) -> Self
  public func alias(_ aliasName: Swift.String) -> Self
  public func insert(_ value: InstaAccountAnalyzeLib.Setter, _ more: InstaAccountAnalyzeLib.Setter...) -> InstaAccountAnalyzeLib.Insert
  public func insert(_ values: [InstaAccountAnalyzeLib.Setter]) -> InstaAccountAnalyzeLib.Insert
  public func insert(or onConflict: InstaAccountAnalyzeLib.OnConflict, _ values: InstaAccountAnalyzeLib.Setter...) -> InstaAccountAnalyzeLib.Insert
  public func insert(or onConflict: InstaAccountAnalyzeLib.OnConflict, _ values: [InstaAccountAnalyzeLib.Setter]) -> InstaAccountAnalyzeLib.Insert
  public func insert() -> InstaAccountAnalyzeLib.Insert
  public func insert(_ query: InstaAccountAnalyzeLib.QueryType) -> InstaAccountAnalyzeLib.Update
  public func update(_ values: InstaAccountAnalyzeLib.Setter...) -> InstaAccountAnalyzeLib.Update
  public func update(_ values: [InstaAccountAnalyzeLib.Setter]) -> InstaAccountAnalyzeLib.Update
  public func delete() -> InstaAccountAnalyzeLib.Delete
  public var exists: InstaAccountAnalyzeLib.Select<Swift.Bool> {
    get
  }
  public func namespace<V>(_ column: InstaAccountAnalyzeLib.Expression<V>) -> InstaAccountAnalyzeLib.Expression<V>
  public subscript<T>(column: InstaAccountAnalyzeLib.Expression<T>) -> InstaAccountAnalyzeLib.Expression<T> {
    get
  }
  public subscript<T>(column: InstaAccountAnalyzeLib.Expression<T?>) -> InstaAccountAnalyzeLib.Expression<T?> {
    get
  }
  public subscript(star: (InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>) -> InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
}
public struct Table : InstaAccountAnalyzeLib.SchemaType {
  public static let identifier: Swift.String
  public var clauses: InstaAccountAnalyzeLib.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct SQLiteView : InstaAccountAnalyzeLib.SchemaType {
  public static let identifier: Swift.String
  public var clauses: InstaAccountAnalyzeLib.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct VirtualTable : InstaAccountAnalyzeLib.SchemaType {
  public static let identifier: Swift.String
  public var clauses: InstaAccountAnalyzeLib.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct ScalarQuery<V> : InstaAccountAnalyzeLib.QueryType {
  public var clauses: InstaAccountAnalyzeLib.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct Select<T> : InstaAccountAnalyzeLib.ExpressionType {
  public var template: Swift.String
  public var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]
  public init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
  public typealias UnderlyingType = Swift.Void
}
public struct Insert : InstaAccountAnalyzeLib.ExpressionType {
  public var template: Swift.String
  public var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]
  public init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
  public typealias UnderlyingType = Swift.Void
}
public struct Update : InstaAccountAnalyzeLib.ExpressionType {
  public var template: Swift.String
  public var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]
  public init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
  public typealias UnderlyingType = Swift.Void
}
public struct Delete : InstaAccountAnalyzeLib.ExpressionType {
  public var template: Swift.String
  public var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]
  public init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
  public typealias UnderlyingType = Swift.Void
}
public struct RowIterator : InstaAccountAnalyzeLib.FailableIterator {
  public typealias Element = InstaAccountAnalyzeLib.Row
  public func failableNext() throws -> InstaAccountAnalyzeLib.Row?
  public func map<T>(_ transform: (InstaAccountAnalyzeLib.RowIterator.Element) throws -> T) throws -> [T]
}
extension Connection {
  final public func prepare(_ query: InstaAccountAnalyzeLib.QueryType) throws -> Swift.AnySequence<InstaAccountAnalyzeLib.Row>
  final public func prepareRowIterator(_ query: InstaAccountAnalyzeLib.QueryType) throws -> InstaAccountAnalyzeLib.RowIterator
  final public func scalar<V>(_ query: InstaAccountAnalyzeLib.ScalarQuery<V>) throws -> V where V : InstaAccountAnalyzeLib.Value
  final public func scalar<V>(_ query: InstaAccountAnalyzeLib.ScalarQuery<V?>) throws -> V.ValueType? where V : InstaAccountAnalyzeLib.Value
  final public func scalar<V>(_ query: InstaAccountAnalyzeLib.Select<V>) throws -> V where V : InstaAccountAnalyzeLib.Value
  final public func scalar<V>(_ query: InstaAccountAnalyzeLib.Select<V?>) throws -> V.ValueType? where V : InstaAccountAnalyzeLib.Value
  final public func pluck(_ query: InstaAccountAnalyzeLib.QueryType) throws -> InstaAccountAnalyzeLib.Row?
  @discardableResult
  final public func run(_ query: InstaAccountAnalyzeLib.Insert) throws -> Swift.Int64
  @discardableResult
  final public func run(_ query: InstaAccountAnalyzeLib.Update) throws -> Swift.Int
  @discardableResult
  final public func run(_ query: InstaAccountAnalyzeLib.Delete) throws -> Swift.Int
}
public struct Row {
  public func get<V>(_ column: InstaAccountAnalyzeLib.Expression<V>) throws -> V where V : InstaAccountAnalyzeLib.Value
  public func get<V>(_ column: InstaAccountAnalyzeLib.Expression<V?>) throws -> V? where V : InstaAccountAnalyzeLib.Value
  public subscript<T>(column: InstaAccountAnalyzeLib.Expression<T>) -> T where T : InstaAccountAnalyzeLib.Value {
    get
  }
  public subscript<T>(column: InstaAccountAnalyzeLib.Expression<T?>) -> T? where T : InstaAccountAnalyzeLib.Value {
    get
  }
}
public enum JoinType : Swift.String {
  case cross
  case inner
  case leftOuter
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum OnConflict : Swift.String {
  case replace
  case rollback
  case abort
  case fail
  case ignore
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct QueryClauses {
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: InstaAccountAnalyzeLib.CipherError, b: InstaAccountAnalyzeLib.CipherError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class StoryHandler : InstaAccountAnalyzeLib.Handler {
  final public func tray(completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Tray, Swift.Error>) -> Swift.Void)
  final public func by(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.TrayElement, Swift.Error>) -> Swift.Void)
  final public func reelBy(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Tray, Swift.Error>) -> Swift.Void)
  final public func highlightsBy(user: InstaAccountAnalyzeLib.User.Reference, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Tray, Swift.Error>) -> Swift.Void)
  @available(*, unavailable, message: "Instagram changed this endpoint. We're working on making it work again.")
  final public func upload(photo: InstaAccountAnalyzeLib.Upload.Picture, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.Upload.Response.Picture, Swift.Error>) -> Swift.Void)
  final public func viewers(forStory storyId: Swift.String, with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.User, InstaAccountAnalyzeLib.StoryViewers>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.User>)
  final public func mark(stories: [InstaAccountAnalyzeLib.Media], with sourceId: Swift.String?, asSeen seen: Swift.Bool, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func reelsMedia(_ feeds: [Swift.String], completionHandler: @escaping (Swift.Result<[Swift.String : InstaAccountAnalyzeLib.TrayElement], Swift.Error>) -> Swift.Void)
  final public func archive(with paginationParameters: InstaAccountAnalyzeLib.PaginationParameters, updateHandler: InstaAccountAnalyzeLib.PaginationUpdateHandler<InstaAccountAnalyzeLib.TrayArchive, InstaAccountAnalyzeLib.AnyPaginatedResponse>?, completionHandler: @escaping InstaAccountAnalyzeLib.PaginationCompletionHandler<InstaAccountAnalyzeLib.TrayArchive>)
  @objc deinit
}
public struct EndpointQuery<Endpoint> : InstaAccountAnalyzeLib.LosselessEndpointRepresentable where Endpoint : InstaAccountAnalyzeLib.LosselessEndpointRepresentable {
  public var endpoint: Endpoint
  public var items: [Swift.String : Swift.String]
  public var components: Foundation.URLComponents? {
    get
  }
  public var placeholders: [Swift.String]? {
    get
  }
  public func filling(_ placeholder: Swift.String, with string: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
  public func query<L>(_ items: [Swift.String : L]) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable! where L : Swift.LosslessStringConvertible
  public func appending(_ path: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
  public var description: Swift.String {
    get
  }
}
public struct RecentActivity : InstaAccountAnalyzeLib.ParsedResponse {
  public struct Count : Swift.Codable {
    public let commentLikes: Swift.Int
    public let campaignNotifications: Swift.Int
    public let likes: Swift.Int
    public let comments: Swift.Int
    public let tags: Swift.Int
    public let relationships: Swift.Int
    public let photosOfYou: Swift.Int
    public let requests: Swift.Int
    public init(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Story : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
    public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
    public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
    public var count: InstaAccountAnalyzeLib.RecentActivity.Count {
      get
    }
    public var arguments: [InstaAccountAnalyzeLib.DynamicResponse] {
      get
    }
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var count: InstaAccountAnalyzeLib.RecentActivity.Count {
    get
  }
  public var suggestedUsers: [InstaAccountAnalyzeLib.SuggestedUser] {
    get
  }
  public var friendRequestStories: [InstaAccountAnalyzeLib.RecentActivity.Story] {
    get
  }
  public var newStories: [InstaAccountAnalyzeLib.RecentActivity.Story] {
    get
  }
  public var oldStories: [InstaAccountAnalyzeLib.RecentActivity.Story] {
    get
  }
  public var continuationToken: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct StatisticsCounterModel {
  public init()
  public var ownerUserId: Swift.Int64
  public var count: Swift.Int
  public var monthYear: Swift.String
  public var weekOfYear: Swift.String
}
public struct Status : Swift.Codable {
  public enum State {
    case ok, fail, unknown
    public static func == (a: InstaAccountAnalyzeLib.Status.State, b: InstaAccountAnalyzeLib.Status.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var status: Swift.String?
  public var state: InstaAccountAnalyzeLib.Status.State {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public class Credentials {
  public enum Verification : Swift.String {
    case email, text
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public enum VerificationCodeType : Swift.String {
    case challenge, sms, backup, totp
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
  }
  public var username: Swift.String {
    get
  }
  public var verification: InstaAccountAnalyzeLib.Credentials.Verification
  public var code: (InstaAccountAnalyzeLib.Credentials.VerificationCodeType, Swift.String)? {
    get
    set
  }
  public init(username: Swift.String, password: Swift.String, verifyBy verification: InstaAccountAnalyzeLib.Credentials.Verification)
  public func resendCode(completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  @objc deinit
}
open class KeychainSwift {
  open var lastResultCode: Darwin.OSStatus
  open var accessGroup: Swift.String?
  open var synchronizable: Swift.Bool
  public init()
  public init(keyPrefix: Swift.String)
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccess access: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccess access: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccess access: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions? = nil) -> Swift.Bool
  open func get(_ key: Swift.String) -> Swift.String?
  open func getData(_ key: Swift.String, asReference: Swift.Bool = false) -> Foundation.Data?
  open func getBool(_ key: Swift.String) -> Swift.Bool?
  @discardableResult
  open func delete(_ key: Swift.String) -> Swift.Bool
  public var allKeys: [Swift.String] {
    get
  }
  @discardableResult
  open func clear() -> Swift.Bool
  @objc deinit
}
public struct KeychainSwiftConstants {
  public static var accessGroup: Swift.String {
    get
  }
  public static var accessible: Swift.String {
    get
  }
  public static var attrAccount: Swift.String {
    get
  }
  public static var attrSynchronizable: Swift.String {
    get
  }
  public static var klass: Swift.String {
    get
  }
  public static var matchLimit: Swift.String {
    get
  }
  public static var returnData: Swift.String {
    get
  }
  public static var valueData: Swift.String {
    get
  }
  public static var returnReference: Swift.String {
    get
  }
  public static var returnAttributes: Swift.String {
    get
  }
  public static var secMatchLimitAll: Swift.String {
    get
  }
}
public enum KeychainSwiftAccessOptions {
  case accessibleWhenUnlocked
  case accessibleWhenUnlockedThisDeviceOnly
  case accessibleAfterFirstUnlock
  case accessibleAfterFirstUnlockThisDeviceOnly
  case accessibleWhenPasscodeSetThisDeviceOnly
  public static func == (a: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions, b: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum PKCS5 {
}
extension AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: InstaAccountAnalyzeLib.Padding = .pkcs7) throws
}
public typealias CipherOperationOnBlock = (Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: InstaAccountAnalyzeLib.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public struct StoryDbModel {
  public init()
  public var storyId: Swift.String
  public var userId: Swift.Int64?
  public var thumbnailUrl: Swift.String?
  public var type: Swift.Int?
  public var sourceUrl: Swift.String?
  public var videoDuration: Swift.Double?
  public var viewCount: Swift.Int
  public var expireAt: Swift.Int64
  public var takenAt: Swift.Int64
  public var isArchived: Swift.Bool
  public var isRefreshViewsAfterArchive: Swift.Bool
}
extension Module {
  public static func RTree<T, U>(_ primaryKey: InstaAccountAnalyzeLib.Expression<T>, _ pairs: (InstaAccountAnalyzeLib.Expression<U>, InstaAccountAnalyzeLib.Expression<U>)...) -> InstaAccountAnalyzeLib.Module where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value, T.Datatype == Swift.Int64, U.Datatype == Swift.Double
}
public struct Thread : InstaAccountAnalyzeLib.ThreadIdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var isMuted: Swift.Bool {
    get
  }
  public var title: Swift.String {
    get
  }
  public var isGroup: Swift.Bool {
    get
  }
  public var users: [InstaAccountAnalyzeLib.User] {
    get
  }
  public var messages: [InstaAccountAnalyzeLib.Message] {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Message : InstaAccountAnalyzeLib.ItemIdentifiableParsedResponse, InstaAccountAnalyzeLib.UserIdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var sentAt: Foundation.Date {
    get
  }
  public var text: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Recipient : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var thread: InstaAccountAnalyzeLib.Thread? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public enum EndpointPath {
  case noVersion(Swift.String)
  case version1(Swift.String)
  case version2(Swift.String)
  case generic(Swift.String)
}
extension EndpointPath : InstaAccountAnalyzeLib.LosselessEndpointRepresentable {
  public var placeholders: [Swift.String]? {
    get
  }
  public func filling(_ placeholder: Swift.String, with string: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
  public func query<L>(_ items: [Swift.String : L]) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable! where L : Swift.LosslessStringConvertible
  public func appending(_ path: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
  public var basePath: Swift.String {
    get
  }
  public var endpointPath: Swift.String {
    get
  }
  public var components: Foundation.URLComponents? {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension EndpointPath : Swift.RawRepresentable, Swift.ExpressibleByStringLiteral, Swift.Equatable {
  public init(stringLiteral value: Swift.String)
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public typealias StringLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
public protocol ExpressionType : InstaAccountAnalyzeLib.Expressible {
  associatedtype UnderlyingType = Swift.Void
  var template: Swift.String { get }
  var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?] { get }
  init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
}
extension ExpressionType {
  public init(literal: Swift.String)
  public init(_ identifier: Swift.String)
  public init<U>(_ expression: U) where U : InstaAccountAnalyzeLib.ExpressionType
}
public struct Expression<Datatype> : InstaAccountAnalyzeLib.ExpressionType {
  public typealias UnderlyingType = Datatype
  public var template: Swift.String
  public var bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]
  public init(_ template: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?])
}
public protocol Expressible {
  var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> { get }
}
extension Expressible {
  public func asSQL() -> Swift.String
}
extension ExpressionType {
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
  public var asc: InstaAccountAnalyzeLib.Expressible {
    get
  }
  public var desc: InstaAccountAnalyzeLib.Expressible {
    get
  }
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib.Value {
  public init(value: Self.UnderlyingType)
}
extension ExpressionType where Self.UnderlyingType : InstaAccountAnalyzeLib._OptionalType, Self.UnderlyingType.WrappedType : InstaAccountAnalyzeLib.Value {
  public static var null: Self {
    get
  }
  public init(value: Self.UnderlyingType.WrappedType?)
}
extension Value {
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
}
public let rowid: InstaAccountAnalyzeLib.Expression<Swift.Int64>
public func cast<T, U>(_ expression: InstaAccountAnalyzeLib.Expression<T>) -> InstaAccountAnalyzeLib.Expression<U> where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value
public func cast<T, U>(_ expression: InstaAccountAnalyzeLib.Expression<T?>) -> InstaAccountAnalyzeLib.Expression<U?> where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value
public struct MediaLikerModel {
  public init()
  public var uid: Swift.Int64
  public var mediaId: Swift.String?
  public var userId: Swift.Int64?
  public var ownerUserId: Swift.Int64?
  public var isDelete: Swift.Bool?
  public var createdAt: Swift.Int64?
}
@_hasMissingDesignatedInitializers public class Handler {
  @objc deinit
}
public class APIHandler {
  public struct Settings {
    public struct Queues {
      public var request: Dispatch.DispatchQueue
      public var working: Dispatch.DispatchQueue
      public var response: Dispatch.DispatchQueue
      public init(request: Dispatch.DispatchQueue = .main, working: Dispatch.DispatchQueue = .global(qos: .userInitiated), response: Dispatch.DispatchQueue = .main)
    }
    public var delay: Swift.ClosedRange<Swift.Double>
    public var queues: InstaAccountAnalyzeLib.APIHandler.Settings.Queues
    public var device: InstaAccountAnalyzeLib.Device
    public var session: Foundation.URLSession
    public init(delay: Swift.ClosedRange<Swift.Double> = 1...2, queues: InstaAccountAnalyzeLib.APIHandler.Settings.Queues = .init(), device: InstaAccountAnalyzeLib.Device? = nil, session: Foundation.URLSession = .shared)
  }
  public var settings: InstaAccountAnalyzeLib.APIHandler.Settings
  public var response: InstaAccountAnalyzeLib.Authentication.Response?
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public init(with settings: InstaAccountAnalyzeLib.APIHandler.Settings = .init())
  public func authenticate(with request: InstaAccountAnalyzeLib.Authentication.Request, completionHandler: @escaping (Swift.Result<(InstaAccountAnalyzeLib.Authentication.Response, InstaAccountAnalyzeLib.APIHandler), Swift.Error>) -> Swift.Void)
  public func invalidate(completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void) throws
  public var users: InstaAccountAnalyzeLib.UserHandler {
    get
  }
  public var comments: InstaAccountAnalyzeLib.CommentHandler {
    get
  }
  public var feeds: InstaAccountAnalyzeLib.FeedHandler {
    get
  }
  public var media: InstaAccountAnalyzeLib.MediaHandler {
    get
  }
  public var messages: InstaAccountAnalyzeLib.MessageHandler {
    get
  }
  public var profile: InstaAccountAnalyzeLib.ProfileHandler {
    get
  }
  public var stories: InstaAccountAnalyzeLib.StoryHandler {
    get
  }
  @objc deinit
}
public enum Gender : Swift.String {
  case male
  case female
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ProfileHandler : InstaAccountAnalyzeLib.Handler {
  final public func markAsPublic(completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func markAsPrivate(completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func update(password: Swift.String, oldPassword: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func edit(username: Swift.String?, name: Swift.String?, biography: Swift.String?, url: Swift.String?, email: Swift.String?, phone: Swift.String?, gender: InstaAccountAnalyzeLib.Gender, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func edit(biography: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func deleteProfilePicture(completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  final public func upload(profilePicture photo: InstaAccountAnalyzeLib.Upload.Picture, completionHandler: @escaping (Swift.Result<Swift.Bool, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public class PrivateKey : InstaAccountAnalyzeLib.SwiftyKey {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
extension String {
  public var camelCased: Swift.String {
    get
  }
  public var snakeCased: Swift.String {
    get
  }
  public var beginningWithUppercase: Swift.String {
    get
  }
  public var beginningWithLowercase: Swift.String {
    get
  }
}
@dynamicMemberLookup public enum DynamicResponse : Swift.Equatable {
  case array([InstaAccountAnalyzeLib.DynamicResponse])
  case number(Foundation.NSNumber)
  case dictionary([Swift.String : InstaAccountAnalyzeLib.DynamicResponse])
  case string(Swift.String)
  case none
  public init(_ object: Any)
  public var beautifiedDescription: Swift.String {
    get
  }
  public var any: Any {
    get
  }
  public var array: [InstaAccountAnalyzeLib.DynamicResponse]? {
    get
  }
  public var bool: Swift.Bool? {
    get
  }
  public var dictionary: [Swift.String : InstaAccountAnalyzeLib.DynamicResponse]? {
    get
  }
  public var double: Swift.Double? {
    get
  }
  public var int: Swift.Int? {
    get
  }
  public var int64: Swift.Int64? {
    get
  }
  public var string: Swift.String? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public subscript(dynamicMember member: Swift.String) -> InstaAccountAnalyzeLib.DynamicResponse {
    get
  }
  public subscript(index: Swift.Int) -> InstaAccountAnalyzeLib.DynamicResponse {
    get
  }
  public subscript(key: Swift.String) -> InstaAccountAnalyzeLib.DynamicResponse {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.DynamicResponse, b: InstaAccountAnalyzeLib.DynamicResponse) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class Statement {
  @objc deinit
  final public var columnCount: Swift.Int {
    get
    set
  }
  final public var columnNames: [Swift.String] {
    get
    set
  }
  final public var row: InstaAccountAnalyzeLib.Cursor {
    get
    set
  }
  final public func bind(_ values: InstaAccountAnalyzeLib.SQLiteBinding?...) -> InstaAccountAnalyzeLib.Statement
  final public func bind(_ values: [InstaAccountAnalyzeLib.SQLiteBinding?]) -> InstaAccountAnalyzeLib.Statement
  final public func bind(_ values: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ bindings: InstaAccountAnalyzeLib.SQLiteBinding?...) throws -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ bindings: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  final public func scalar(_ bindings: InstaAccountAnalyzeLib.SQLiteBinding?...) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  final public func scalar(_ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  final public func scalar(_ bindings: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  final public func step() throws -> Swift.Bool
}
extension Statement : Swift.Sequence {
  final public func makeIterator() -> InstaAccountAnalyzeLib.Statement
  public typealias Iterator = InstaAccountAnalyzeLib.Statement
}
public protocol FailableIterator : Swift.IteratorProtocol {
  func failableNext() throws -> Self.Element?
}
extension FailableIterator {
  public func next() -> Self.Element?
}
extension Array {
  public init<I>(_ failableIterator: I) throws where Element == I.Element, I : InstaAccountAnalyzeLib.FailableIterator
}
extension Statement : InstaAccountAnalyzeLib.FailableIterator {
  public typealias Element = [InstaAccountAnalyzeLib.SQLiteBinding?]
  final public func failableNext() throws -> [InstaAccountAnalyzeLib.SQLiteBinding?]?
}
extension Statement : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public struct Cursor {
  public subscript(idx: Swift.Int) -> Swift.Double {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Int64 {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.String {
    get
  }
  public subscript(idx: Swift.Int) -> InstaAccountAnalyzeLib.Blob {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Bool {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Int {
    get
  }
}
extension Cursor : Swift.Sequence {
  public subscript(idx: Swift.Int) -> InstaAccountAnalyzeLib.SQLiteBinding? {
    get
  }
  public func makeIterator() -> Swift.AnyIterator<InstaAccountAnalyzeLib.SQLiteBinding?>
  public typealias Element = InstaAccountAnalyzeLib.SQLiteBinding?
  public typealias Iterator = Swift.AnyIterator<InstaAccountAnalyzeLib.SQLiteBinding?>
}
extension Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: InstaAccountAnalyzeLib.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: InstaAccountAnalyzeLib.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: InstaAccountAnalyzeLib.Authenticator) throws -> Foundation.Data
}
extension Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
public class CMAC : InstaAccountAnalyzeLib.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: InstaAccountAnalyzeLib.CMAC.Error, b: InstaAccountAnalyzeLib.CMAC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
  func makeDecryptor() throws -> InstaAccountAnalyzeLib.Cryptor & InstaAccountAnalyzeLib.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public enum PKCS7 {
}
public struct Cover : InstaAccountAnalyzeLib.CoverIdentifiableParsedResponse {
  public var content: InstaAccountAnalyzeLib.Media.Version? {
    get
  }
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct PreviewComment2 : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public var text: Swift.String {
    get
  }
  public var type: Swift.Int {
    get
  }
  public var userId: Swift.Int64 {
    get
  }
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var createdAt: Foundation.Date {
    get
  }
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Usertags2 : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Media : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public struct Version : Swift.Codable {
    public var url: Foundation.URL
    public var size: CoreGraphics.CGSize
    public var aspectRatio: CoreGraphics.CGFloat {
      get
    }
    public var resolution: CoreGraphics.CGFloat {
      get
    }
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Picture : Swift.Codable {
    public let versions: [InstaAccountAnalyzeLib.Media.Version]
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Video : Swift.Codable {
    public let duration: Foundation.TimeInterval
    public let versions: [InstaAccountAnalyzeLib.Media.Version]
    public let thumbnails: [InstaAccountAnalyzeLib.Media.Version]
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public enum Content : Swift.Codable {
    case picture(InstaAccountAnalyzeLib.Media.Picture)
    case video(InstaAccountAnalyzeLib.Media.Video)
    case album([InstaAccountAnalyzeLib.Media.Content])
    case none
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct IgtvSeriesInfoModel : Swift.Codable {
    public let id: Swift.Int64
    public let title: Swift.String
    public let numEpisodes: Swift.Int
    public init(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var expiringAt: Foundation.Date {
    get
  }
  public var takenAt: Foundation.Date {
    get
  }
  public var size: CoreGraphics.CGSize {
    get
  }
  public var aspectRatio: CoreGraphics.CGFloat {
    get
  }
  public var resolution: CoreGraphics.CGFloat {
    get
  }
  public var userTags: [InstaAccountAnalyzeLib.Usertags2] {
    get
  }
  public var previewComments: [InstaAccountAnalyzeLib.PreviewComment2] {
    get
  }
  public var caption: InstaAccountAnalyzeLib.Comment? {
    get
  }
  public var comments: Swift.Int {
    get
  }
  public var likes: Swift.Int {
    get
  }
  public var videoViewCount: Swift.Int {
    get
  }
  public var shortCode: Swift.String {
    get
  }
  public var takenAtRaw: Swift.Int64 {
    get
  }
  public var type: Swift.String {
    get
  }
  public var mediaType: Swift.Int {
    get
  }
  public var totalViewerCount: Swift.Int {
    get
  }
  public var videoDuration: Swift.Double {
    get
  }
  public var igtvSeriesInfo: InstaAccountAnalyzeLib.Media.IgtvSeriesInfoModel? {
    get
  }
  public var content: InstaAccountAnalyzeLib.Media.Content {
    get
  }
  public var user: InstaAccountAnalyzeLib.User? {
    get
  }
  public var locations: [InstaAccountAnalyzeLib.StoryLocation] {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension Media.Content {
  public var thumbnails: [[InstaAccountAnalyzeLib.Media.Version]] {
    get
  }
  public var sources: [[InstaAccountAnalyzeLib.Media.Version]] {
    get
  }
}
extension Collection where Self.Element : Swift.Collection, Self.Element.Element == InstaAccountAnalyzeLib.Media.Version {
  public func with(aspectRatio: CoreGraphics.CGFloat) -> [[InstaAccountAnalyzeLib.Media.Version]]
  public var squared: [[InstaAccountAnalyzeLib.Media.Version]] {
    get
  }
  public var largest: [InstaAccountAnalyzeLib.Media.Version?] {
    get
  }
  public var smallest: [InstaAccountAnalyzeLib.Media.Version?] {
    get
  }
}
extension Collection where Self.Element == InstaAccountAnalyzeLib.Media.Version? {
  public var valid: [InstaAccountAnalyzeLib.Media.Version] {
    get
  }
}
extension Collection where Self.Element == InstaAccountAnalyzeLib.Media.Version {
  public func with(aspectRatio: CoreGraphics.CGFloat) -> [InstaAccountAnalyzeLib.Media.Version]
  public var squared: [InstaAccountAnalyzeLib.Media.Version] {
    get
  }
  public var largest: InstaAccountAnalyzeLib.Media.Version? {
    get
  }
  public var smallest: InstaAccountAnalyzeLib.Media.Version? {
    get
  }
}
public struct IgtvResponseModel : InstaAccountAnalyzeLib.ParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var media: [InstaAccountAnalyzeLib.Media] {
    get
  }
  public var hasNextPage: Swift.Bool {
    get
  }
  public var maxId: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension SchemaType {
  public func drop(ifExists: Swift.Bool = false) -> Swift.String
}
extension Table {
  public func create(temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, withoutRowid: Swift.Bool = false, block: (InstaAccountAnalyzeLib.TableBuilder) -> Swift.Void) -> Swift.String
  public func create(_ query: InstaAccountAnalyzeLib.QueryType, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V) -> Swift.String where V : InstaAccountAnalyzeLib.Value
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V) -> Swift.String where V : InstaAccountAnalyzeLib.Value
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V? = nil) -> Swift.String where V : InstaAccountAnalyzeLib.Value
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V? = nil) -> Swift.String where V : InstaAccountAnalyzeLib.Value
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V? = nil, collate: InstaAccountAnalyzeLib.Collation) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V? = nil, collate: InstaAccountAnalyzeLib.Collation) -> Swift.String where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  public func rename(_ to: InstaAccountAnalyzeLib.Table) -> Swift.String
  public func createIndex(_ columns: InstaAccountAnalyzeLib.Expressible..., unique: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func dropIndex(_ columns: InstaAccountAnalyzeLib.Expressible..., ifExists: Swift.Bool = false) -> Swift.String
}
extension SQLiteView {
  public func create(_ query: InstaAccountAnalyzeLib.QueryType, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func drop(ifExists: Swift.Bool = false) -> Swift.String
}
extension VirtualTable {
  public func create(_ using: InstaAccountAnalyzeLib.Module, ifNotExists: Swift.Bool = false) -> Swift.String
  public func rename(_ to: InstaAccountAnalyzeLib.VirtualTable) -> Swift.String
}
@_hasMissingDesignatedInitializers final public class TableBuilder {
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V?>) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V?>) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, primaryKey: Swift.Bool, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, primaryKey: Swift.Bool, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil) where V : InstaAccountAnalyzeLib.Value
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, primaryKey: InstaAccountAnalyzeLib.PrimaryKey, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, primaryKey: InstaAccountAnalyzeLib.PrimaryKey, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<V>) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: InstaAccountAnalyzeLib.Expression<V?>, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool>? = nil, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V>? = nil, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: InstaAccountAnalyzeLib.Expression<V?>, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: InstaAccountAnalyzeLib.Expression<V?>, unique: Swift.Bool = false, check: InstaAccountAnalyzeLib.Expression<Swift.Bool?>, defaultValue: V, collate: InstaAccountAnalyzeLib.Collation) where V : InstaAccountAnalyzeLib.Value, V.Datatype == Swift.String
  final public func primaryKey<T>(_ column: InstaAccountAnalyzeLib.Expression<T>) where T : InstaAccountAnalyzeLib.Value
  final public func primaryKey<T, U>(_ compositeA: InstaAccountAnalyzeLib.Expression<T>, _ b: InstaAccountAnalyzeLib.Expression<U>) where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value
  final public func primaryKey<T, U, V>(_ compositeA: InstaAccountAnalyzeLib.Expression<T>, _ b: InstaAccountAnalyzeLib.Expression<U>, _ c: InstaAccountAnalyzeLib.Expression<V>) where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value, V : InstaAccountAnalyzeLib.Value
  final public func primaryKey<T, U, V, W>(_ compositeA: InstaAccountAnalyzeLib.Expression<T>, _ b: InstaAccountAnalyzeLib.Expression<U>, _ c: InstaAccountAnalyzeLib.Expression<V>, _ d: InstaAccountAnalyzeLib.Expression<W>) where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value, V : InstaAccountAnalyzeLib.Value, W : InstaAccountAnalyzeLib.Value
  final public func unique(_ columns: InstaAccountAnalyzeLib.Expressible...)
  final public func unique(_ columns: [InstaAccountAnalyzeLib.Expressible])
  final public func check(_ condition: InstaAccountAnalyzeLib.Expression<Swift.Bool>)
  final public func check(_ condition: InstaAccountAnalyzeLib.Expression<Swift.Bool?>)
  public enum Dependency : Swift.String {
    case noAction
    case restrict
    case setNull
    case setDefault
    case cascade
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  final public func foreignKey<T>(_ column: InstaAccountAnalyzeLib.Expression<T>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<T>, update: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil, delete: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil) where T : InstaAccountAnalyzeLib.Value
  final public func foreignKey<T>(_ column: InstaAccountAnalyzeLib.Expression<T?>, references table: InstaAccountAnalyzeLib.QueryType, _ other: InstaAccountAnalyzeLib.Expression<T>, update: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil, delete: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil) where T : InstaAccountAnalyzeLib.Value
  final public func foreignKey<T, U>(_ composite: (InstaAccountAnalyzeLib.Expression<T>, InstaAccountAnalyzeLib.Expression<U>), references table: InstaAccountAnalyzeLib.QueryType, _ other: (InstaAccountAnalyzeLib.Expression<T>, InstaAccountAnalyzeLib.Expression<U>), update: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil, delete: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil) where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value
  final public func foreignKey<T, U, V>(_ composite: (InstaAccountAnalyzeLib.Expression<T>, InstaAccountAnalyzeLib.Expression<U>, InstaAccountAnalyzeLib.Expression<V>), references table: InstaAccountAnalyzeLib.QueryType, _ other: (InstaAccountAnalyzeLib.Expression<T>, InstaAccountAnalyzeLib.Expression<U>, InstaAccountAnalyzeLib.Expression<V>), update: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil, delete: InstaAccountAnalyzeLib.TableBuilder.Dependency? = nil) where T : InstaAccountAnalyzeLib.Value, U : InstaAccountAnalyzeLib.Value, V : InstaAccountAnalyzeLib.Value
  @objc deinit
}
public enum PrimaryKey {
  case `default`
  case autoincrement
  public static func == (a: InstaAccountAnalyzeLib.PrimaryKey, b: InstaAccountAnalyzeLib.PrimaryKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct Module {
  public init(_ name: Swift.String, _ arguments: [InstaAccountAnalyzeLib.Expressible])
}
extension Module : InstaAccountAnalyzeLib.Expressible {
  public var expression: InstaAccountAnalyzeLib.Expression<Swift.Void> {
    get
  }
}
public struct StalkerCandidateEntityModel {
  public var userId: Swift.Int64
  public var ownerUserId: Swift.Int64
  public var logDate: Swift.Int64
  public var isSeen: Swift.Bool
  public init(userId: Swift.Int64, ownerUserId: Swift.Int64)
}
public struct StalkerCandidateWithMetadataModel {
  public init()
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
  public var stalkerCandidateEntityModel: InstaAccountAnalyzeLib.StalkerCandidateEntityModel?
}
public protocol _UInt8Type {
}
extension UInt8 : InstaAccountAnalyzeLib._UInt8Type {
}
extension UInt8 {
  public func bits() -> [InstaAccountAnalyzeLib.Bit]
  public func bits() -> Swift.String
}
public struct NotificationEntityModel {
  public var uid: Swift.Int
  public var ownerUserId: Swift.Int64?
  public var type: InstaAccountAnalyzeLib.NotificationTypes
  public var createdAt: Swift.Int64?
  public init(ownerUserId: Swift.Int64?, type: InstaAccountAnalyzeLib.NotificationTypes)
}
public enum NotificationTypes : Swift.Int {
  public typealias RawValue = Swift.Int
  case none
  case newFollowers
  case lostFollowers
  case blockedFollowers
  case newMediaLikers
  case newMediaComments
  case stalkers
  case storyStalkers
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct UserStoryViewCountModel {
  public init()
  public var userId: Swift.Int64
  public var views: Swift.Int
  public var userName: Swift.String?
  public var fullName: Swift.String?
  public var profilePictureUrl: Swift.String?
  public var isPrivate: Swift.Bool?
  public var isVerified: Swift.Bool?
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
}
public struct MediaDeletedUserModel {
  public init()
  public var mediaId: Swift.String?
  public var mediaModel: InstaAccountAnalyzeLib.MediaModel?
  public var createdAt: Swift.Int64?
  public var commentText: Swift.String?
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
}
public class PublicKey : InstaAccountAnalyzeLib.SwiftyKey {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [InstaAccountAnalyzeLib.PublicKey]
  @objc deinit
}
public struct PCBC : InstaAccountAnalyzeLib.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.PCBC.Error, b: InstaAccountAnalyzeLib.PCBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
extension Date : InstaAccountAnalyzeLib.Value {
  public static var declaredDatatype: Swift.String {
    get
  }
  public static func fromDatatypeValue(_ stringValue: Swift.String) -> Foundation.Date
  public var datatypeValue: Swift.String {
    get
  }
  public typealias ValueType = Foundation.Date
  public typealias Datatype = Swift.String
}
public var dateFormatter: Foundation.DateFormatter
@_hasMissingDesignatedInitializers public class DateFunctions {
  public static func date(_ timestring: Swift.String, _ modifiers: Swift.String...) -> InstaAccountAnalyzeLib.Expression<Foundation.Date?>
  public static func time(_ timestring: Swift.String, _ modifiers: Swift.String...) -> InstaAccountAnalyzeLib.Expression<Foundation.Date?>
  public static func datetime(_ timestring: Swift.String, _ modifiers: Swift.String...) -> InstaAccountAnalyzeLib.Expression<Foundation.Date?>
  public static func julianday(_ timestring: Swift.String, _ modifiers: Swift.String...) -> InstaAccountAnalyzeLib.Expression<Foundation.Date?>
  public static func strftime(_ format: Swift.String, _ timestring: Swift.String, _ modifiers: Swift.String...) -> InstaAccountAnalyzeLib.Expression<Foundation.Date?>
  @objc deinit
}
extension Date {
  public var date: InstaAccountAnalyzeLib.Expression<Foundation.Date?> {
    get
  }
  public var time: InstaAccountAnalyzeLib.Expression<Foundation.Date?> {
    get
  }
  public var datetime: InstaAccountAnalyzeLib.Expression<Foundation.Date?> {
    get
  }
  public var julianday: InstaAccountAnalyzeLib.Expression<Foundation.Date?> {
    get
  }
}
extension Expression where Datatype == Foundation.Date {
  public var date: InstaAccountAnalyzeLib.Expression<Foundation.Date> {
    get
  }
  public var time: InstaAccountAnalyzeLib.Expression<Foundation.Date> {
    get
  }
  public var datetime: InstaAccountAnalyzeLib.Expression<Foundation.Date> {
    get
  }
  public var julianday: InstaAccountAnalyzeLib.Expression<Foundation.Date> {
    get
  }
}
public class Signature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: InstaAccountAnalyzeLib.Signature.DigestType, b: InstaAccountAnalyzeLib.Signature.DigestType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
public enum DynamicRequest : Swift.Equatable {
  case array([InstaAccountAnalyzeLib.DynamicRequest])
  case number(Foundation.NSNumber)
  case dictionary([Swift.String : InstaAccountAnalyzeLib.DynamicRequest])
  case string(Swift.String)
  case none
  public init(_ object: Any)
  public var any: Any {
    get
  }
  public static func == (a: InstaAccountAnalyzeLib.DynamicRequest, b: InstaAccountAnalyzeLib.DynamicRequest) -> Swift.Bool
}
extension DynamicRequest : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension DynamicRequest : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension DynamicRequest : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension DynamicRequest : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension DynamicRequest : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension DynamicRequest : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension DynamicRequest : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
public protocol SwiftyRSAMessage {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension SwiftyRSAMessage {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
public struct StoryLocation : InstaAccountAnalyzeLib.IdentifiableParsedResponse {
  public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
  public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
  public var identity: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.StoryLocation> {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var city: Swift.String? {
    get
  }
  public var coordinates: CoreGraphics.CGPoint {
    get
  }
  public var name: Swift.String {
    get
  }
  public var shortName: Swift.String {
    get
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum Bit : Swift.Int {
  case zero
  case one
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public protocol CipherModeWorker {
  var cipherOperation: InstaAccountAnalyzeLib.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : InstaAccountAnalyzeLib.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension HMAC {
  convenience public init(key: Swift.String, variant: InstaAccountAnalyzeLib.HMAC.Variant = .md5) throws
}
public protocol ParsedResponse : Swift.Decodable, Swift.Encodable {
  var rawResponse: InstaAccountAnalyzeLib.DynamicResponse { get }
  init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
}
public struct Identifier<Element> : Swift.Hashable {
  public var primaryKey: Swift.Int?
  public var identifier: Swift.String?
  public init(primaryKey: Swift.Int? = nil, identifier: Swift.String? = nil)
  public func primaryKey(_ primaryKey: Swift.Int) -> InstaAccountAnalyzeLib.Identifier<Element>
  public func identifier(_ identifier: Swift.String) -> InstaAccountAnalyzeLib.Identifier<Element>
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: InstaAccountAnalyzeLib.Identifier<Element>, b: InstaAccountAnalyzeLib.Identifier<Element>) -> Swift.Bool
}
public protocol IdentifiableParsedResponse : InstaAccountAnalyzeLib.ParsedResponse {
  var identity: Self.Identity { get }
}
extension IdentifiableParsedResponse {
  public typealias Identity = InstaAccountAnalyzeLib.Identifier<Self>
  public var identity: InstaAccountAnalyzeLib.Identifier<Self> {
    get
  }
}
public protocol UserIdentifiableParsedResponse : InstaAccountAnalyzeLib.ParsedResponse {
  var userIdentity: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.User> { get }
}
extension UserIdentifiableParsedResponse {
  public var userIdentity: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.User> {
    get
  }
}
public protocol ThreadIdentifiableParsedResponse : InstaAccountAnalyzeLib.ParsedResponse {
  var threadIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Thread> { get }
}
extension ThreadIdentifiableParsedResponse {
  public var threadIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Thread> {
    get
  }
  public var viewerIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.User> {
    get
  }
}
public protocol ItemIdentifiableParsedResponse : InstaAccountAnalyzeLib.ParsedResponse {
  var itemIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Message> { get }
}
extension ItemIdentifiableParsedResponse {
  public var itemIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Message> {
    get
  }
}
public protocol CoverIdentifiableParsedResponse : InstaAccountAnalyzeLib.ParsedResponse {
  var mediaIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Media> { get }
}
extension CoverIdentifiableParsedResponse {
  public var mediaIdentifier: InstaAccountAnalyzeLib.Identifier<InstaAccountAnalyzeLib.Media> {
    get
  }
}
extension Module {
  public static func FTS4(_ column: InstaAccountAnalyzeLib.Expressible, _ more: InstaAccountAnalyzeLib.Expressible...) -> InstaAccountAnalyzeLib.Module
  public static func FTS4(_ columns: [InstaAccountAnalyzeLib.Expressible] = [], tokenize tokenizer: InstaAccountAnalyzeLib.Tokenizer? = nil) -> InstaAccountAnalyzeLib.Module
  public static func FTS4(_ config: InstaAccountAnalyzeLib.FTS4Config) -> InstaAccountAnalyzeLib.Module
}
extension VirtualTable {
  public func match(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func match(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool>
  public func match(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.Expression<Swift.Bool?>
  public func match(_ pattern: Swift.String) -> InstaAccountAnalyzeLib.QueryType
  public func match(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String>) -> InstaAccountAnalyzeLib.QueryType
  public func match(_ pattern: InstaAccountAnalyzeLib.Expression<Swift.String?>) -> InstaAccountAnalyzeLib.QueryType
}
public struct Tokenizer {
  public static let Simple: InstaAccountAnalyzeLib.Tokenizer
  public static let Porter: InstaAccountAnalyzeLib.Tokenizer
  public static func Unicode61(removeDiacritics: Swift.Bool? = nil, tokenchars: Swift.Set<Swift.Character> = [], separators: Swift.Set<Swift.Character> = []) -> InstaAccountAnalyzeLib.Tokenizer
  public static func Custom(_ name: Swift.String) -> InstaAccountAnalyzeLib.Tokenizer
  public let name: Swift.String
  public let arguments: [Swift.String]
}
extension Tokenizer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Connection {
  final public func registerTokenizer(_ submoduleName: Swift.String, next: @escaping (Swift.String) -> (Swift.String, Swift.Range<Swift.String.Index>)?) throws
}
@_hasMissingDesignatedInitializers open class FTSConfig {
  public enum ColumnOption {
    case unindexed
    public static func == (a: InstaAccountAnalyzeLib.FTSConfig.ColumnOption, b: InstaAccountAnalyzeLib.FTSConfig.ColumnOption) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @discardableResult
  open func column(_ column: InstaAccountAnalyzeLib.Expressible, _ options: [InstaAccountAnalyzeLib.FTSConfig.ColumnOption] = []) -> Self
  @discardableResult
  open func columns(_ columns: [InstaAccountAnalyzeLib.Expressible]) -> Self
  open func tokenizer(_ tokenizer: InstaAccountAnalyzeLib.Tokenizer?) -> Self
  open func prefix(_ prefix: [Swift.Int]) -> Self
  open func externalContent(_ schema: InstaAccountAnalyzeLib.SchemaType) -> Self
  open func contentless() -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers open class FTS4Config : InstaAccountAnalyzeLib.FTSConfig {
  public enum MatchInfo : Swift.CustomStringConvertible {
    case fts3
    public var description: Swift.String {
      get
    }
    public static func == (a: InstaAccountAnalyzeLib.FTS4Config.MatchInfo, b: InstaAccountAnalyzeLib.FTS4Config.MatchInfo) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Order : Swift.CustomStringConvertible {
    case asc
    case desc
    public var description: Swift.String {
      get
    }
    public static func == (a: InstaAccountAnalyzeLib.FTS4Config.Order, b: InstaAccountAnalyzeLib.FTS4Config.Order) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init()
  open func compress(_ functionName: Swift.String) -> Self
  open func uncompress(_ functionName: Swift.String) -> Self
  open func languageId(_ columnName: Swift.String) -> Self
  open func matchInfo(_ matchInfo: InstaAccountAnalyzeLib.FTS4Config.MatchInfo) -> Self
  open func order(_ order: InstaAccountAnalyzeLib.FTS4Config.Order) -> Self
  @objc deinit
}
public protocol IInstaFetcherProcessor {
  func getCurrentUser(completionHandler: @escaping (InstaAccountAnalyzeLib.User?) -> Swift.Void)
  func friendDetailSync(userId: Swift.Int64) -> InstaAccountAnalyzeLib.User?
  func getUserInfoAnonymousSync(username: Swift.String) -> InstaAccountAnalyzeLib.AnonymousUserInfoModel?
  func friendDetail(userId: Swift.Int64, completionHandler: @escaping (Swift.Result<InstaAccountAnalyzeLib.User, Swift.Error>) -> Swift.Void)
  func getUserFollowersWithPaging(userId: Swift.Int64?, searchQuery: Swift.String?, nextMaxId: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.User], Swift.String?) -> Swift.Void)
  func getUserFollowingWithPaging(userId: Swift.Int64?, searchQuery: Swift.String?, nextMaxId: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.User], Swift.String?) -> Swift.Void)
  func getStoryArchieve(nextMaxId: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.TrayArchive]?, Swift.String?) -> Swift.Void)
  func getStoryArchieveMedias(ids: [Swift.String], completionHandler: @escaping ([Swift.String : InstaAccountAnalyzeLib.TrayElement]?) -> Swift.Void)
  func friendshipShowAsync(userId: Swift.Int64) -> InstaAccountAnalyzeLib.Friendship?
  func friendshipShow(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.Friendship?) -> Swift.Void)
  func getStoryUserList(completionHandler: @escaping (InstaAccountAnalyzeLib.Tray?) -> Swift.Void)
  func getUserStories(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.TrayElement?) -> Swift.Void)
  func followUser(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.Friendship?) -> Swift.Void)
  func unfollowUser(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.Friendship?) -> Swift.Void)
  func followUserSync(userId: Swift.Int64) -> InstaAccountAnalyzeLib.Friendship?
  func unfollowUserSync(userId: Swift.Int64) -> InstaAccountAnalyzeLib.Friendship?
  func getUserPosts(userId: Swift.Int64, nextMaxId: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.Media]?, Swift.String?, Swift.Bool) -> Swift.Void)
  func getPostDetail(mediaId: Swift.String, completionHandler: @escaping (InstaAccountAnalyzeLib.Media?) -> Swift.Void)
  func getPostDetailSync(mediaId: Swift.String) -> InstaAccountAnalyzeLib.Media?
  func searchUsers(query: Swift.String, completionHandler: @escaping ([InstaAccountAnalyzeLib.User]?) -> Swift.Void)
  func getMostPostsInTimeline(completionHandler: @escaping ([InstaAccountAnalyzeLib.User]?) -> Swift.Void)
  func getFriendStatusMany(userIds: [Swift.Int], completionHandler: @escaping ([InstaAccountAnalyzeLib.User.Reference : InstaAccountAnalyzeLib.Friendship]?) -> Swift.Void)
  func getUserPendingFriendRequestsToMe(completionHandler: @escaping ([InstaAccountAnalyzeLib.User]?) -> Swift.Void)
  func getUserPendingFriendRequestsToFriends(cursor: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.AnonymousUserInfoModel]?, Swift.String?) -> Swift.Void)
  func getUserPendingFriendRequestsToFriendsOnlyUsername(cursor: Swift.String?, completionHandler: @escaping ([InstaAccountAnalyzeLib.FollowRequestItemModel]?, Swift.String?) -> Swift.Void)
}
public struct SuggestedUserModel {
  public init()
  public var userId: Swift.Int64?
  public var ownerUserId: Swift.Int64
  public var userName: Swift.String?
  public var fullName: Swift.String?
  public var profilePictureUrl: Swift.String?
  public var isNewSuggestion: Swift.Bool
  public var logDate: Swift.Int64
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: InstaAccountAnalyzeLib.CCM.Error, b: InstaAccountAnalyzeLib.CCM.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public protocol EndpointRepresentable {
  var representation: InstaAccountAnalyzeLib.LosselessEndpointRepresentable { get }
}
extension EndpointRepresentable {
  public func url() throws -> Foundation.URL
  public func user(_ userPk: Swift.Int) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func user(_ username: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func media(_ mediaId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func upload(_ uploadId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func comment(_ commentId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable
  public func thread(_ threadId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func tag(_ tagId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func apiPath(_ apiPath: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func bloksAction(_ bloksAction: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func next(_ maxId: Swift.String?) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func rank(_ token: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func type(_ mediaType: InstaAccountAnalyzeLib.MediaType) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func q(_ query: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func query(_ query: Swift.String?) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func deviceId(_ deviceId: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func challenge(_ context: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func cursor(_ cursor: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
  public func appending(_ path: Swift.String) -> InstaAccountAnalyzeLib.EndpointRepresentable!
}
public protocol LosselessEndpointRepresentable : InstaAccountAnalyzeLib.EndpointRepresentable, Swift.CustomStringConvertible {
  var components: Foundation.URLComponents? { get }
  var placeholders: [Swift.String]? { get }
  func filling(_ placeholder: Swift.String, with string: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
  func query<L>(_ items: [Swift.String : L]) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable! where L : Swift.LosslessStringConvertible
  func appending(_ path: Swift.String) -> InstaAccountAnalyzeLib.LosselessEndpointRepresentable!
}
extension LosselessEndpointRepresentable {
  public var representation: InstaAccountAnalyzeLib.LosselessEndpointRepresentable {
    get
  }
}
public protocol RawEndpointRepresentable : InstaAccountAnalyzeLib.EndpointRepresentable, Swift.RawRepresentable where Self.RawValue : InstaAccountAnalyzeLib.LosselessEndpointRepresentable {
}
extension RawEndpointRepresentable {
  public var representation: InstaAccountAnalyzeLib.LosselessEndpointRepresentable {
    get
  }
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: InstaAccountAnalyzeLib.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: InstaAccountAnalyzeLib.SHA2.Variant.RawValue)
  }
  public init(variant: InstaAccountAnalyzeLib.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension SHA2 : InstaAccountAnalyzeLib.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
@available(*, renamed: "Digest")
public typealias Hash = InstaAccountAnalyzeLib.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: InstaAccountAnalyzeLib.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: InstaAccountAnalyzeLib.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public struct CBC : InstaAccountAnalyzeLib.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: InstaAccountAnalyzeLib.CBC.Error, b: InstaAccountAnalyzeLib.CBC.Error) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let options: InstaAccountAnalyzeLib.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping InstaAccountAnalyzeLib.CipherOperationOnBlock) throws -> InstaAccountAnalyzeLib.CipherModeWorker
}
public typealias Image = UIKit.UIImage
public enum Upload {
  public struct Picture {
    public var image: InstaAccountAnalyzeLib.Image
    public var caption: Swift.String
    public var disableComments: Swift.Bool
    public var size: CoreGraphics.CGSize
    public init(image: InstaAccountAnalyzeLib.Image, caption: Swift.String, disableComments: Swift.Bool, size: CoreGraphics.CGSize)
  }
  public struct Album {
    public var images: [InstaAccountAnalyzeLib.Image]
    public var caption: Swift.String
    public var disableComments: Swift.Bool
    public init(images: [InstaAccountAnalyzeLib.Image], caption: Swift.String, disableComments: Swift.Bool)
  }
  public struct Video {
    public var thumbnail: InstaAccountAnalyzeLib.Image
    public var data: Foundation.Data
    public var caption: Swift.String
    public var isAudioMuted: Swift.Bool
    public var size: CoreGraphics.CGSize
    public var disableComments: Swift.Bool
    public init(thumbnail: InstaAccountAnalyzeLib.Image, data: Foundation.Data, caption: Swift.String, isAudioMuted: Swift.Bool, size: CoreGraphics.CGSize, disableComments: Swift.Bool)
  }
  case picture(InstaAccountAnalyzeLib.Upload.Picture)
  case video(InstaAccountAnalyzeLib.Upload.Video)
}
extension User {
  public struct Tag : Swift.Codable {
    public let userId: Swift.Int
    public let position: CoreGraphics.CGPoint
    public init(userId: Swift.Int, position: CoreGraphics.CGPoint)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Tags : Swift.Codable {
    public let adding: [InstaAccountAnalyzeLib.User.Tag]
    public let removing: [Swift.Int]
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
}
public struct Authentication {
  public enum Request {
    case user(InstaAccountAnalyzeLib.Credentials)
    @available(iOS 11, OSX 10.13, macCatalyst 13, *)
    case webView(InstaAccountAnalyzeLib.LoginWebView)
    case cache(InstaAccountAnalyzeLib.Authentication.Response)
  }
  public struct Response : Swift.Codable {
    public init(device: InstaAccountAnalyzeLib.Device, storage: InstaAccountAnalyzeLib.Authentication.Storage, data: [Foundation.Data])
    public var device: InstaAccountAnalyzeLib.Device
    public var identifier: Swift.String? {
      get
    }
    public var user: InstaAccountAnalyzeLib.User? {
      get
    }
    public func persist(withAccess access: InstaAccountAnalyzeLib.KeychainSwiftAccessOptions? = nil) -> Swift.String?
    public static func persisted(with key: Swift.String) -> InstaAccountAnalyzeLib.Authentication.Response?
    @discardableResult
    public static func invalidate(persistedWithKey key: Swift.String) -> Swift.Bool
    @discardableResult
    public func invalidate() -> Swift.Bool
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct Storage : Swift.Codable {
    public var dsUserId: Swift.String
    public var csrfToken: Swift.String
    public var sessionId: Swift.String
    public var rankToken: Swift.String
    public var user: InstaAccountAnalyzeLib.User?
    public init(dsUserId: Swift.String, csrfToken: Swift.String, sessionId: Swift.String, rankToken: Swift.String, user: InstaAccountAnalyzeLib.User?)
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
}
public class ClearMessage : InstaAccountAnalyzeLib.SwiftyRSAMessage {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: InstaAccountAnalyzeLib.PublicKey, padding: InstaAccountAnalyzeLib.SwiftyRSAPadding) throws -> InstaAccountAnalyzeLib.EncryptedMessage
  public func signed(with key: InstaAccountAnalyzeLib.PrivateKey, digestType: InstaAccountAnalyzeLib.Signature.DigestType) throws -> InstaAccountAnalyzeLib.Signature
  public func verify(with key: InstaAccountAnalyzeLib.PublicKey, signature: InstaAccountAnalyzeLib.Signature, digestType: InstaAccountAnalyzeLib.Signature.DigestType) throws -> Swift.Bool
  @objc deinit
}
public protocol IDBRepository {
  func getBestPostDays(userId: Swift.Int64) -> [InstaAccountAnalyzeLib.BestTimeForPostModel]
  func getBestPostHours(userId: Swift.Int64) -> [InstaAccountAnalyzeLib.BestTimeForPostModel]
  func getBestPostDaysHours(userId: Swift.Int64) -> [InstaAccountAnalyzeLib.BestTimeForPostModel]
  func getCloseFriends(userId: Swift.Int64, completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func updateAppUser(appUser: InstaAccountAnalyzeLib.AppUserModel)
  func getDashboardStats(completionHandler: @escaping (InstaAccountAnalyzeLib.UserDashboardDetailView?) -> Swift.Void)
  func getTop5PopuplarMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getMostEngagedTop5UsersWithMetadata(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getUserDetails(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.EngagedUserWithMetadataModel?) -> Swift.Void)
  func updatefollowingStateDb(engagedUser: InstaAccountAnalyzeLib.EngagedUserModel)
  func getFollowings(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getFollowers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getFollowersByAsc(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getMostEngagedUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getMostCommentUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getMostLikeUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getLeastEngagedUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getLeastCommentUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getLeastLikeUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getUserStatsLimit(limit: Swift.Int, completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStatsModel]?) -> Swift.Void)
  func getUserStats(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStatsModel]?) -> Swift.Void)
  func getUserStatByDate(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStatsModel]?) -> Swift.Void)
  func getLostUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getGainedUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getBlockMeUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getClosedAccounts(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getFollowingsNotFollowYou(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getFollowersYouFollow(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getFollowersYouNotFollow(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getLikeOrCommentButNoFollowUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getNoLikeOrCommentUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getNoLikeOrCommentFollowers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getYouMostLikedUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getYouLikedButNoFollowUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getTagYouUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getUserActiveStories(completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryDbModel]?) -> Swift.Void)
  func getArchivedStories(completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryDbModel]?) -> Swift.Void)
  func getStoryViewers(storyId: Swift.String, completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryViewerWithMetadataModel]?) -> Swift.Void)
  func getNotFolloweLeastViewedCount(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStoryViewCountModel]?) -> Swift.Void)
  func getNotFollowMeViewedStory(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStoryViewCountModel]?) -> Swift.Void)
  func getFollowerMostViewedCount(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStoryViewCountModel]?) -> Swift.Void)
  func getFollowerLeastViewedCount(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserStoryViewCountModel]?) -> Swift.Void)
  func getLeastViewedStories(completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryDbModel]?) -> Swift.Void)
  func getMostViewedStories(completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryDbModel]?) -> Swift.Void)
  func storiesUpdateAllDefaultToFalse()
  func insertStories(models: [InstaAccountAnalyzeLib.StoryDbModel])
  func getStoryById(id: Swift.String, completionHandler: @escaping (InstaAccountAnalyzeLib.StoryDbModel?) -> Swift.Void)
  func updateStory(model: InstaAccountAnalyzeLib.StoryDbModel)
  func getDefaultAppUser(completionHandler: @escaping (InstaAccountAnalyzeLib.AppUserModel?) -> Swift.Void)
  func deleteByUserId(uid: Swift.Int)
  func getAllUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.AppUserModel]?) -> Swift.Void)
  func updateUsers(models: [InstaAccountAnalyzeLib.AppUserModel])
  func updateAllDefaultToFalse()
  func insertAppUser(model: InstaAccountAnalyzeLib.AppUserModel, completionHandler: @escaping (Swift.Int64?) -> Swift.Void)
  func getEngagedUser(userId: Swift.Int64, completionHandler: @escaping (InstaAccountAnalyzeLib.EngagedUserModel?) -> Swift.Void)
  func updateEngagedUser(model: InstaAccountAnalyzeLib.EngagedUserModel)
  func insertUser(model: InstaAccountAnalyzeLib.InstaUserMetadataModel, completionHandler: @escaping (Swift.Int64?) -> Swift.Void)
  func insertUserEngagement(model: InstaAccountAnalyzeLib.EngagedUserModel, completionHandler: @escaping (Swift.Int64?) -> Swift.Void)
  func getYourBesties(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getDashboardStatsSync(completionHandler: @escaping (InstaAccountAnalyzeLib.UserDashboardDetailView?) -> Swift.Void)
  func insertUserStats(model: InstaAccountAnalyzeLib.UserStatsModel, completionHandler: @escaping (Swift.Int64?) -> Swift.Void)
  func getMostLikedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getMostCommentedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getMostPopularMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getMostViewedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getLeastLikedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getLeastCommentedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getLeastPopularMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getLeastViewedMedias(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getUsersDeleteComment(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaDeletedUserModel]?) -> Swift.Void)
  func getUsersDeleteLike(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaDeletedUserModel]?) -> Swift.Void)
  func getUsersDeleteLikeOrComment(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaDeletedUserModel]?) -> Swift.Void)
  func getMediaUploadPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getCommentPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getLikePerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getMediaUploadPerWeek(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getCommentPerWeek(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getLikePerWeek(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getLostFollowerPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getBlockFollowerPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getNewFollowerPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getStoryPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getStoryViewPerMonth(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getNewFollowerPerWeek(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getLostFollowerPerWeek(completionHandler: @escaping ([InstaAccountAnalyzeLib.StatisticsCounterModel]?) -> Swift.Void)
  func getDbUserAllPosts(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getDbUserAllVideoPosts(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getDbUserAllPhotoPosts(completionHandler: @escaping ([InstaAccountAnalyzeLib.MediaModel]?) -> Swift.Void)
  func getDbUserAllStories(completionHandler: @escaping ([InstaAccountAnalyzeLib.StoryDbModel]?) -> Swift.Void)
  func getStalkerCandidates(completionHandler: @escaping ([InstaAccountAnalyzeLib.StalkerCandidateWithMetadataModel]?) -> Swift.Void)
  func getAllSuggestedUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.SuggestedUserModel]?) -> Swift.Void)
  func getBlockedByMeUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getUsersDeleteTag(completionHandler: @escaping ([InstaAccountAnalyzeLib.UserTagWithMetadataModel]?) -> Swift.Void)
  func getYouUnfollows(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserWithMetadataModel]?) -> Swift.Void)
  func getNotifications() -> [InstaAccountAnalyzeLib.NotificationEntityModel]
  func deleteAllNotifications()
  func deleteNotification(uid: Swift.Int?)
  func deleteNotification(type: InstaAccountAnalyzeLib.NotificationTypes)
  func getStalkerCandidates() -> [InstaAccountAnalyzeLib.StalkerCandidateWithMetadataModel]
  func updateAllStalkersSeen()
  func clearUserHistory()
  func logoutUser() -> InstaAccountAnalyzeLib.AppUserModel!
  func getFavUsers() -> [InstaAccountAnalyzeLib.EngagedUserBookmarkedWithMetadataModel]
  func getFavUsers(completionHandler: @escaping ([InstaAccountAnalyzeLib.EngagedUserBookmarkedWithMetadataModel]?) -> Swift.Void)
  func insertBookmarkedUser(_ model: InstaAccountAnalyzeLib.EngagedUserBookmarkedModel) -> Swift.Int64?
  func deleteBookmark(_ model: InstaAccountAnalyzeLib.EngagedUserBookmarkedModel)
}
public struct UserDashboardDetailView {
  public init()
  public var followingNotFollowCount: Swift.Int
  public var followingFollowCount: Swift.Int
  public var followerNotFollow: Swift.Int
  public var newFollowerCount: Swift.Int
  public var lostFollowerCount: Swift.Int
  public var blockFollowerCount: Swift.Int
  public var blockedByMeFollowerCount: Swift.Int
  public var closedAccountsCount: Swift.Int
  public var totalLikeCount: Swift.Int
  public var totalCommentCount: Swift.Int
  public var totalMediaCount: Swift.Int
  public var totalVideoCount: Swift.Int
  public var totalPhotoCount: Swift.Int
  public var totalStoryCount: Swift.Int
  public var followingCount: Swift.Int
  public var followerCount: Swift.Int
  public var totalTagDeleteCount: Swift.Int
  public var totalCommentDeleteCount: Swift.Int
  public var totalLikeDeleteCount: Swift.Int
}
extension Module {
  public static func FTS5(_ config: InstaAccountAnalyzeLib.FTS5Config) -> InstaAccountAnalyzeLib.Module
}
@_inheritsConvenienceInitializers open class FTS5Config : InstaAccountAnalyzeLib.FTSConfig {
  public enum Detail : Swift.CustomStringConvertible {
    case full
    case column
    case none
    public var description: Swift.String {
      get
    }
    public static func == (a: InstaAccountAnalyzeLib.FTS5Config.Detail, b: InstaAccountAnalyzeLib.FTS5Config.Detail) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public init()
  open func contentRowId(_ column: InstaAccountAnalyzeLib.Expressible) -> Self
  open func columnSize(_ size: Swift.Int) -> Self
  open func detail(_ detail: InstaAccountAnalyzeLib.FTS5Config.Detail) -> Self
  @objc deinit
}
extension Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers open class PostDao {
  @objc deinit
}
final public class Connection {
  public enum Location {
    case inMemory
    case temporary
    case uri(Swift.String)
  }
  public enum Operation {
    case insert
    case update
    case delete
    public static func == (a: InstaAccountAnalyzeLib.Connection.Operation, b: InstaAccountAnalyzeLib.Connection.Operation) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public var handle: Swift.OpaquePointer {
    get
  }
  public init(_ location: InstaAccountAnalyzeLib.Connection.Location = .inMemory, readonly: Swift.Bool = false) throws
  convenience public init(_ filename: Swift.String, readonly: Swift.Bool = false) throws
  @objc deinit
  final public var readonly: Swift.Bool {
    get
  }
  final public var lastInsertRowid: Swift.Int64 {
    get
  }
  final public var changes: Swift.Int {
    get
  }
  final public var totalChanges: Swift.Int {
    get
  }
  final public func execute(_ SQL: Swift.String) throws
  final public func prepare(_ statement: Swift.String, _ bindings: InstaAccountAnalyzeLib.SQLiteBinding?...) throws -> InstaAccountAnalyzeLib.Statement
  final public func prepare(_ statement: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  final public func prepare(_ statement: Swift.String, _ bindings: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: InstaAccountAnalyzeLib.SQLiteBinding?...) throws -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.Statement
  final public func scalar(_ statement: Swift.String, _ bindings: InstaAccountAnalyzeLib.SQLiteBinding?...) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  final public func scalar(_ statement: Swift.String, _ bindings: [InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  final public func scalar(_ statement: Swift.String, _ bindings: [Swift.String : InstaAccountAnalyzeLib.SQLiteBinding?]) throws -> InstaAccountAnalyzeLib.SQLiteBinding?
  public enum TransactionMode : Swift.String {
    case deferred
    case immediate
    case exclusive
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  final public func transaction(_ mode: InstaAccountAnalyzeLib.Connection.TransactionMode = .deferred, block: () throws -> Swift.Void) throws
  final public func savepoint(_ name: Swift.String = UUID().uuidString, block: () throws -> Swift.Void) throws
  final public func interrupt()
  final public var busyTimeout: Swift.Double {
    get
    set
  }
  final public func busyHandler(_ callback: ((Swift.Int) -> Swift.Bool)?)
  final public func trace(_ callback: ((Swift.String) -> Swift.Void)?)
  final public func updateHook(_ callback: ((InstaAccountAnalyzeLib.Connection.Operation, Swift.String, Swift.String, Swift.Int64) -> Swift.Void)?)
  final public func commitHook(_ callback: (() throws -> Swift.Void)?)
  final public func rollbackHook(_ callback: (() -> Swift.Void)?)
  final public func createFunction(_ function: Swift.String, argumentCount: Swift.UInt? = nil, deterministic: Swift.Bool = false, _ block: @escaping ([InstaAccountAnalyzeLib.SQLiteBinding?]) -> InstaAccountAnalyzeLib.SQLiteBinding?)
  final public func createCollation(_ collation: Swift.String, _ block: @escaping (Swift.String, Swift.String) -> Foundation.ComparisonResult) throws
}
extension Connection : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension Connection.Location : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum SqliteResult : Swift.Error {
  case error(message: Swift.String, code: Swift.Int32, statement: InstaAccountAnalyzeLib.Statement?)
}
extension SqliteResult : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct ConfigureStoryUploadModel : Swift.Codable {
  public var uuid: Swift.String
  public var uid: Swift.String
  public var csrfToken: Swift.String
  public var sourceType: Swift.String
  public var caption: Swift.String
  public var uploadId: Swift.String
  public var disableComments: Swift.Bool
  public var configureMode: Swift.Int
  public var cameraPosition: Swift.String
  public init(uuid: Swift.String, uid: Swift.String, csrfToken: Swift.String, sourceType: Swift.String, caption: Swift.String, uploadId: Swift.String, disableComments: Swift.Bool, configureMode: Swift.Int, cameraPosition: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct SeenStory : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct EngagedUserModel {
  public init()
  public var userId: Swift.Int64
  public var ownerUserId: Swift.Int64
  public var isYouFollowing: Swift.Bool
  public var isFollower: Swift.Bool
  public var likedPostsCount: Swift.Int
  public var commentedPostsCount: Swift.Int
  public var storiesWatchedCount: Swift.Int
  public var youLikedPostsCount: Swift.Int
  public var youCommentedPostsCount: Swift.Int
  public var taggedPostsCount: Swift.Int
  public var taggedYouPostsCount: Swift.Int
  public var isBlockMe: Swift.Bool
  public var isYouUnfollow: Swift.Bool
  public var isUnfollower: Swift.Bool
  public var isNewFollower: Swift.Bool
  public var isBestFriend: Swift.Bool
  public var isBlockedByMe: Swift.Bool
  public var lastFollowStatChageDate: Swift.Int64
  public var followerIndex: Swift.Int64?
}
public struct EngagedUserWithMetadataModel {
  public var userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel?
  public var engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel?
  public init()
  public init(userMetadataModel: InstaAccountAnalyzeLib.InstaUserMetadataModel, engagedUserModel: InstaAccountAnalyzeLib.EngagedUserModel)
}
extension Upload {
  public struct Response {
    public struct Picture : InstaAccountAnalyzeLib.ParsedResponse {
      public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
      public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
      public var media: InstaAccountAnalyzeLib.Media? {
        get
      }
      public var uploadId: Swift.String? {
        get
      }
      public var status: Swift.String? {
        get
      }
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
    public struct Album : InstaAccountAnalyzeLib.ParsedResponse {
      public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
      public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
      public var media: InstaAccountAnalyzeLib.Media? {
        get
      }
      public var sidecarId: Swift.String? {
        get
      }
      public var status: Swift.String? {
        get
      }
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
    public struct Video : InstaAccountAnalyzeLib.ParsedResponse {
      public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
      public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
      public var media: InstaAccountAnalyzeLib.Media? {
        get
      }
      public var uploadId: Swift.String? {
        get
      }
      public var status: Swift.String? {
        get
      }
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
    public struct Offset {
      public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
      public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
      public var offset: Swift.Int? {
        get
      }
      public var status: Swift.String? {
        get
      }
      public init(from decoder: Swift.Decoder) throws
      public func encode(to encoder: Swift.Encoder) throws
    }
  }
}
extension Upload.Response.Video {
  public struct URL : InstaAccountAnalyzeLib.ParsedResponse {
    public init?(rawResponse: InstaAccountAnalyzeLib.DynamicResponse)
    public let rawResponse: InstaAccountAnalyzeLib.DynamicResponse
    public var url: Swift.String? {
      get
    }
    public var job: Swift.String? {
      get
    }
    public var expires: Swift.Double? {
      get
    }
    public init(from decoder: Swift.Decoder) throws
    public func encode(to encoder: Swift.Encoder) throws
  }
}
public typealias Star = (InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>
public func * (_: InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?, _: InstaAccountAnalyzeLib.Expression<InstaAccountAnalyzeLib.SQLiteBinding>?) -> InstaAccountAnalyzeLib.Expression<Swift.Void>
public protocol _OptionalType {
  associatedtype WrappedType
}
extension Optional : InstaAccountAnalyzeLib._OptionalType {
  public typealias WrappedType = Wrapped
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
extension Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias Element = InstaAccountAnalyzeLib.BlockModeOption
  public typealias ArrayLiteralElement = InstaAccountAnalyzeLib.BlockModeOption
  public typealias RawValue = Swift.Int
}
extension InstaAccountAnalyzeLib.GCM.Mode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.GCM.Mode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.GCM.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.GCM.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Poly1305.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Poly1305.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension InstaAccountAnalyzeLib.OFB.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.OFB.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.MediaType : Swift.Equatable {}
extension InstaAccountAnalyzeLib.MediaType : Swift.Hashable {}
extension InstaAccountAnalyzeLib.MediaType : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.HMAC.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.HMAC.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.HMAC.Variant : Swift.Equatable {}
extension InstaAccountAnalyzeLib.HMAC.Variant : Swift.Hashable {}
extension InstaAccountAnalyzeLib.MediaComments : InstaAccountAnalyzeLib.ParsedResponse {}
extension InstaAccountAnalyzeLib.HTC : Swift.Equatable {}
extension InstaAccountAnalyzeLib.HTC : Swift.Hashable {}
extension InstaAccountAnalyzeLib.LG : Swift.Equatable {}
extension InstaAccountAnalyzeLib.LG : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Samsung : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Samsung : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Sony : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Sony : Swift.Hashable {}
extension InstaAccountAnalyzeLib._objc_Signature.DigestType : Swift.Equatable {}
extension InstaAccountAnalyzeLib._objc_Signature.DigestType : Swift.Hashable {}
extension InstaAccountAnalyzeLib._objc_Signature.DigestType : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.SwKeyStore.SecError : Swift.Equatable {}
extension InstaAccountAnalyzeLib.SwKeyStore.SecError : Swift.Hashable {}
extension InstaAccountAnalyzeLib.SwKeyStore.SecError : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.SwKeyConvert.SwError : Swift.Equatable {}
extension InstaAccountAnalyzeLib.SwKeyConvert.SwError : Swift.Hashable {}
extension InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PEM.EncryptedPrivateKey.EncMode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.CCError : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.CCError : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.CCError : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.DigestAlgorithm : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.DigestAlgorithm : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.DigestAlgorithm : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.HMACAlg : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.HMACAlg : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.HMACAlg : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.OpMode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.OpMode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.OpMode : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.BlockMode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.BlockMode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.BlockMode : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.AuthBlockMode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.AuthBlockMode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.AuthBlockMode : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.Algorithm : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.Algorithm : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.Algorithm : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.Padding : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.Padding : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.Padding : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricPadding : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricPadding : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricPadding : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricSAPadding : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricSAPadding : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.RSA.AsymmetricSAPadding : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.DH.DHParam : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.DH.DHParam : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.CRC.Mode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.CRC.Mode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.CRC.Mode : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CC.KeyDerivation.PRFAlg : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CC.KeyDerivation.PRFAlg : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CC.KeyDerivation.PRFAlg : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.HKDF.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.HKDF.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Padding : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Padding : Swift.Hashable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.SHA3.Variant : Swift.Equatable {}
extension InstaAccountAnalyzeLib.SHA3.Variant : Swift.Hashable {}
extension InstaAccountAnalyzeLib.StoryViewers : InstaAccountAnalyzeLib.ParsedResponse {}
extension InstaAccountAnalyzeLib.Rabbit.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Rabbit.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.AnyPaginatedResponse : InstaAccountAnalyzeLib.ParsedResponse {}
extension InstaAccountAnalyzeLib.ChaCha20.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.ChaCha20.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Blowfish.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Blowfish.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CTR : InstaAccountAnalyzeLib.BlockMode {}
extension InstaAccountAnalyzeLib.CTR.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CTR.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.FollowerStateTypes : Swift.Equatable {}
extension InstaAccountAnalyzeLib.FollowerStateTypes : Swift.Hashable {}
extension InstaAccountAnalyzeLib.FollowerStateTypes : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.AES.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.AES.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.AES.Variant : Swift.Equatable {}
extension InstaAccountAnalyzeLib.AES.Variant : Swift.Hashable {}
extension InstaAccountAnalyzeLib.AES.Variant : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CFB.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CFB.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.JoinType : Swift.Equatable {}
extension InstaAccountAnalyzeLib.JoinType : Swift.Hashable {}
extension InstaAccountAnalyzeLib.JoinType : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.OnConflict : Swift.Equatable {}
extension InstaAccountAnalyzeLib.OnConflict : Swift.Hashable {}
extension InstaAccountAnalyzeLib.OnConflict : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CipherError : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CipherError : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Status.State : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Status.State : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Credentials.Verification : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Credentials.Verification : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Credentials.Verification : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.Credentials.VerificationCodeType : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Credentials.VerificationCodeType : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Credentials.VerificationCodeType : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.KeychainSwiftAccessOptions : Swift.Equatable {}
extension InstaAccountAnalyzeLib.KeychainSwiftAccessOptions : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Gender : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Gender : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Gender : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.CMAC.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CMAC.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.TableBuilder.Dependency : Swift.Equatable {}
extension InstaAccountAnalyzeLib.TableBuilder.Dependency : Swift.Hashable {}
extension InstaAccountAnalyzeLib.TableBuilder.Dependency : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.PrimaryKey : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PrimaryKey : Swift.Hashable {}
extension InstaAccountAnalyzeLib.NotificationTypes : Swift.Equatable {}
extension InstaAccountAnalyzeLib.NotificationTypes : Swift.Hashable {}
extension InstaAccountAnalyzeLib.NotificationTypes : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.PCBC.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.PCBC.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Signature.DigestType : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Signature.DigestType : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Bit : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Bit : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Bit : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.FTSConfig.ColumnOption : Swift.Equatable {}
extension InstaAccountAnalyzeLib.FTSConfig.ColumnOption : Swift.Hashable {}
extension InstaAccountAnalyzeLib.FTS4Config.MatchInfo : Swift.Equatable {}
extension InstaAccountAnalyzeLib.FTS4Config.MatchInfo : Swift.Hashable {}
extension InstaAccountAnalyzeLib.FTS4Config.Order : Swift.Equatable {}
extension InstaAccountAnalyzeLib.FTS4Config.Order : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CCM : InstaAccountAnalyzeLib.BlockMode {}
extension InstaAccountAnalyzeLib.CCM.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CCM.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.SHA2.Variant : Swift.Equatable {}
extension InstaAccountAnalyzeLib.SHA2.Variant : Swift.Hashable {}
extension InstaAccountAnalyzeLib.CBC.Error : Swift.Equatable {}
extension InstaAccountAnalyzeLib.CBC.Error : Swift.Hashable {}
extension InstaAccountAnalyzeLib.FTS5Config.Detail : Swift.Equatable {}
extension InstaAccountAnalyzeLib.FTS5Config.Detail : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Connection.Operation : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Connection.Operation : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Connection.TransactionMode : Swift.Equatable {}
extension InstaAccountAnalyzeLib.Connection.TransactionMode : Swift.Hashable {}
extension InstaAccountAnalyzeLib.Connection.TransactionMode : Swift.RawRepresentable {}
extension InstaAccountAnalyzeLib.Upload.Response.Offset : InstaAccountAnalyzeLib.ParsedResponse {}
